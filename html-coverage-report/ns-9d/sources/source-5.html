


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > InlineDelegateByteBuddyMockMaker</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.mockito.internal.creation.bytebuddy</a>
</div>

<h1>Coverage Summary for Class: InlineDelegateByteBuddyMockMaker (org.mockito.internal.creation.bytebuddy)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InlineDelegateByteBuddyMockMaker</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (8/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.7%
  </span>
  <span class="absValue">
    (11/126)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (78/273)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InlineDelegateByteBuddyMockMaker$1</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (2/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    43.5%
  </span>
  <span class="absValue">
    (10/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.6%
  </span>
  <span class="absValue">
    (13/136)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.4%
  </span>
  <span class="absValue">
    (80/282)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.mockito.internal.creation.bytebuddy;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.WeakHashMap;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.function.BiConsumer;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;import net.bytebuddy.agent.ByteBuddyAgent;
&nbsp;import org.mockito.MockedConstruction;
&nbsp;import org.mockito.creation.instance.InstantiationException;
&nbsp;import org.mockito.creation.instance.Instantiator;
&nbsp;import org.mockito.exceptions.base.MockitoException;
&nbsp;import org.mockito.exceptions.base.MockitoInitializationException;
&nbsp;import org.mockito.exceptions.misusing.MockitoConfigurationException;
&nbsp;import org.mockito.internal.SuppressSignatureCheck;
&nbsp;import org.mockito.internal.configuration.plugins.Plugins;
&nbsp;import org.mockito.internal.creation.instance.ConstructorInstantiator;
&nbsp;import org.mockito.internal.util.Platform;
&nbsp;import org.mockito.internal.util.StringUtil;
&nbsp;import org.mockito.internal.util.concurrent.DetachedThreadLocal;
&nbsp;import org.mockito.internal.util.concurrent.WeakConcurrentMap;
&nbsp;import org.mockito.internal.util.concurrent.DetachedThreadLocal.Cleaner;
&nbsp;import org.mockito.invocation.MockHandler;
&nbsp;import org.mockito.mock.MockCreationSettings;
&nbsp;import org.mockito.plugins.InlineMockMaker;
&nbsp;import org.mockito.plugins.MemberAccessor;
&nbsp;import org.mockito.plugins.MockMaker;
&nbsp;
&nbsp;@SuppressSignatureCheck
&nbsp;class InlineDelegateByteBuddyMockMaker implements ClassCreatingMockMaker, InlineMockMaker, Instantiator {
&nbsp;    private static final Instrumentation INSTRUMENTATION;
&nbsp;    private static final Throwable INITIALIZATION_ERROR;
&nbsp;    private final BytecodeGenerator bytecodeGenerator;
&nbsp;    private final WeakConcurrentMap&lt;Object, MockMethodInterceptor&gt; mocks = new WeakConcurrentMap(false);
&nbsp;    private final DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt;&gt; mockedStatics;
&nbsp;    private final DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt;&gt; mockedConstruction;
&nbsp;    private final ThreadLocal&lt;Boolean&gt; mockitoConstruction;
&nbsp;    private final ThreadLocal&lt;Object&gt; currentSpied;
&nbsp;
&nbsp;    InlineDelegateByteBuddyMockMaker() {
&nbsp;        this.mockedStatics = new DetachedThreadLocal(Cleaner.MANUAL);
&nbsp;        this.mockedConstruction = new DetachedThreadLocal(Cleaner.MANUAL);
&nbsp;        this.mockitoConstruction = ThreadLocal.withInitial(() -&gt; {
&nbsp;            return false;
&nbsp;        });
&nbsp;        this.currentSpied = new ThreadLocal();
&nbsp;        if (INITIALIZATION_ERROR == null) {
&nbsp;            ThreadLocal&lt;Class&lt;?&gt;&gt; currentConstruction = new ThreadLocal();
&nbsp;            ThreadLocal&lt;Boolean&gt; isSuspended = ThreadLocal.withInitial(() -&gt; {
&nbsp;                return false;
&nbsp;            });
&nbsp;            Predicate&lt;Class&lt;?&gt;&gt; isCallFromSubclassConstructor = StackWalkerChecker.orFallback();
&nbsp;            Predicate&lt;Class&lt;?&gt;&gt; isMockConstruction = (type) -&gt; {
&nbsp;                if ((Boolean)isSuspended.get()) {
&nbsp;                    return false;
&nbsp;                } else if (!(Boolean)this.mockitoConstruction.get() &amp;&amp; currentConstruction.get() == null) {
&nbsp;                    Map&lt;Class&lt;?&gt;, ?&gt; interceptors = (Map)this.mockedConstruction.get();
&nbsp;                    if (interceptors != null &amp;&amp; interceptors.containsKey(type)) {
&nbsp;                        if (isCallFromSubclassConstructor.test(type)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            currentConstruction.set(type);
&nbsp;                            return true;
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    return true;
&nbsp;                }
&nbsp;            };
&nbsp;            ConstructionCallback onConstruction = (type, object, arguments, parameterTypeNames) -&gt; {
&nbsp;                if ((Boolean)this.mockitoConstruction.get()) {
&nbsp;                    Object spy = this.currentSpied.get();
&nbsp;                    if (spy == null) {
&nbsp;                        return null;
&nbsp;                    } else if (type.isInstance(spy)) {
&nbsp;                        return spy;
&nbsp;                    } else {
&nbsp;                        isSuspended.set(true);
&nbsp;
&nbsp;                        try {
&nbsp;                            String var10002 = type.getName();
&nbsp;                            throw new MockitoException(&quot;Unexpected spy for &quot; + var10002 + &quot; on instance of &quot; + object.getClass().getName(), object instanceof Throwable ? (Throwable)object : null);
&nbsp;                        } finally {
&nbsp;                            isSuspended.set(false);
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                } else if (currentConstruction.get() != type) {</b>
&nbsp;                    return null;
&nbsp;                } else {
<b class="fc">&nbsp;                    currentConstruction.remove();</b>
<b class="pc">&nbsp;                    isSuspended.set(true);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    try {</b>
&nbsp;                        Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors = (Map)this.mockedConstruction.get();
&nbsp;                        if (interceptors != null) {
&nbsp;                            BiConsumer&lt;Object, MockedConstruction.Context&gt; interceptor = (BiConsumer)interceptors.get(type);
&nbsp;                            if (interceptor != null) {
<b class="fc">&nbsp;                                interceptor.accept(object, new InlineConstructionMockContext(arguments, object.getClass(), parameterTypeNames));</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        isSuspended.set(false);</b>
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    return null;
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            };</b>
<b class="pc">&nbsp;            this.bytecodeGenerator = new TypeCachingBytecodeGenerator(new InlineBytecodeGenerator(INSTRUMENTATION, this.mocks, this.mockedStatics, isMockConstruction, onConstruction), true);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            String detail;</b>
&nbsp;            if (System.getProperty(&quot;java.specification.vendor&quot;, &quot;&quot;).toLowerCase().contains(&quot;android&quot;)) {
&nbsp;                detail = &quot;It appears as if you are trying to run this mock maker on Android which does not support the instrumentation API.&quot;;
&nbsp;            } else {
&nbsp;                try {
&nbsp;                    if (INITIALIZATION_ERROR instanceof NoClassDefFoundError &amp;&amp; INITIALIZATION_ERROR.getMessage() != null &amp;&amp; INITIALIZATION_ERROR.getMessage().startsWith(&quot;net/bytebuddy/agent/&quot;)) {
&nbsp;                        detail = StringUtil.join(new Object[]{&quot;It seems like you are running Mockito with an incomplete or inconsistent class path. Byte Buddy Agent could not be loaded.&quot;, &quot;&quot;, &quot;Byte Buddy Agent is available on Maven Central as &#39;net.bytebuddy:byte-buddy-agent&#39; with the module name &#39;net.bytebuddy.agent&#39;.&quot;, &quot;Normally, your IDE or build tool (such as Maven or Gradle) should take care of your class path completion but &quot;});
<b class="nc">&nbsp;                    } else if (Class.forName(&quot;javax.tools.ToolProvider&quot;).getMethod(&quot;getSystemJavaCompiler&quot;).invoke((Object)null) == null) {</b>
&nbsp;                        detail = &quot;It appears as if you are running on a JRE. Either install a JDK or add JNA to the class path.&quot;;
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        detail = &quot;It appears as if your JDK does not supply a working agent attachment mechanism.&quot;;
&nbsp;                    }
<b class="fc">&nbsp;                } catch (Throwable var6) {</b>
<b class="fc">&nbsp;                    detail = &quot;It appears as if you are running an incomplete JVM installation that might not support all tooling APIs&quot;;</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            throw new MockitoInitializationException(StringUtil.join(new Object[]{&quot;Could not initialize inline Byte Buddy mock maker.&quot;, &quot;&quot;, detail, Platform.describe()}), INITIALIZATION_ERROR);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    public &lt;T&gt; T createMock(MockCreationSettings&lt;T&gt; settings, MockHandler handler) {</b>
<b class="fc">&nbsp;        return this.doCreateMock(settings, handler, false);</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public &lt;T&gt; Optional&lt;T&gt; createSpy(MockCreationSettings&lt;T&gt; settings, MockHandler handler, T object) {</b>
&nbsp;        if (object == null) {
<b class="fc">&nbsp;            throw new MockitoConfigurationException(&quot;Spy instance must not be null&quot;);</b>
&nbsp;        } else {
&nbsp;            this.currentSpied.set(object);
&nbsp;
<b class="nc">&nbsp;            Optional var4;</b>
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                var4 = Optional.ofNullable(this.doCreateMock(settings, handler, true));</b>
&nbsp;            } finally {
&nbsp;                this.currentSpied.remove();
&nbsp;            }
&nbsp;
&nbsp;            return var4;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    private &lt;T&gt; T doCreateMock(MockCreationSettings&lt;T&gt; settings, MockHandler handler, boolean nullOnNonInlineConstruction) {
&nbsp;        Class&lt;? extends T&gt; type = this.createMockType(settings);
&nbsp;
&nbsp;        try {
&nbsp;            Object instance;
&nbsp;            if (settings.isUsingConstructor()) {
&nbsp;                instance = (new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs())).newInstance(type);
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                try {</b>
<b class="nc">&nbsp;                    instance = this.newInstance(type);</b>
<b class="fc">&nbsp;                } catch (InstantiationException var8) {</b>
<b class="fc">&nbsp;                    if (nullOnNonInlineConstruction) {</b>
<b class="fc">&nbsp;                        return null;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);
&nbsp;                    instance = instantiator.newInstance(type);
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(handler, settings);</b>
&nbsp;            this.mocks.put(instance, mockMethodInterceptor);
&nbsp;            if (instance instanceof MockAccess) {
<b class="fc">&nbsp;                ((MockAccess)instance).setMockitoInterceptor(mockMethodInterceptor);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            this.mocks.expungeStaleEntries();</b>
&nbsp;            return instance;
<b class="fc">&nbsp;        } catch (InstantiationException var9) {</b>
&nbsp;            InstantiationException e = var9;
<b class="fc">&nbsp;            throw new MockitoException(&quot;Unable to create mock instance of type &#39;&quot; + type.getSimpleName() + &quot;&#39;&quot;, e);</b>
<b class="pc">&nbsp;        }</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public &lt;T&gt; Class&lt;? extends T&gt; createMockType(MockCreationSettings&lt;T&gt; settings) {</b>
<b class="nc">&nbsp;        try {</b>
<b class="nc">&nbsp;            return this.bytecodeGenerator.mockClass(MockFeatures.withMockFeatures(settings.getTypeToMock(), settings.getExtraInterfaces(), settings.getSerializableMode(), settings.isStripAnnotations(), settings.getDefaultAnswer()));</b>
&nbsp;        } catch (Exception var3) {
&nbsp;            Exception bytecodeGenerationFailed = var3;
&nbsp;            throw this.prettifyFailure(settings, bytecodeGenerationFailed);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    private &lt;T&gt; RuntimeException prettifyFailure(MockCreationSettings&lt;T&gt; mockFeatures, Exception generationFailed) {</b>
<b class="nc">&nbsp;        if (mockFeatures.getTypeToMock().isArray()) {</b>
<b class="nc">&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Arrays cannot be mocked: &quot; + mockFeatures.getTypeToMock() + &quot;.&quot;, &quot;&quot;}), generationFailed);</b>
<b class="nc">&nbsp;        } else if (Modifier.isFinal(mockFeatures.getTypeToMock().getModifiers())) {</b>
&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Mockito cannot mock this class: &quot; + mockFeatures.getTypeToMock() + &quot;.&quot;, &quot;Can not mock final classes with the following settings :&quot;, &quot; - explicit serialization (e.g. withSettings().serializable())&quot;, &quot; - extra interfaces (e.g. withSettings().extraInterfaces(...))&quot;, &quot;&quot;, &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;, &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;, &quot;&quot;, &quot;Underlying exception : &quot; + generationFailed}), generationFailed);
&nbsp;        } else if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Mockito cannot mock this class: &quot; + mockFeatures.getTypeToMock() + &quot;.&quot;, &quot;Most likely it is a private class that is not visible by Mockito&quot;, &quot;&quot;, &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;, &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;, &quot;&quot;}), generationFailed);
&nbsp;        } else {
<b class="nc">&nbsp;            Object[] var10002 = new Object[11];</b>
<b class="nc">&nbsp;            Class var10005 = mockFeatures.getTypeToMock();</b>
<b class="nc">&nbsp;            var10002[0] = &quot;Mockito cannot mock this class: &quot; + var10005 + &quot;.&quot;;</b>
&nbsp;            var10002[1] = &quot;&quot;;
<b class="nc">&nbsp;            var10002[2] = &quot;If you&#39;re not sure why you&#39;re getting this error, please open an issue on GitHub.&quot;;</b>
&nbsp;            var10002[3] = &quot;&quot;;
&nbsp;            var10002[4] = Platform.warnForVM(&quot;IBM J9 VM&quot;, &quot;Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n&quot;, &quot;Hotspot&quot;, Platform.isJava8BelowUpdate45() ? &quot;Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n&quot; : &quot;&quot;);
<b class="nc">&nbsp;            var10002[5] = Platform.describe();</b>
&nbsp;            var10002[6] = &quot;&quot;;
&nbsp;            var10002[7] = &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;;
<b class="nc">&nbsp;            var10002[8] = &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;;</b>
<b class="nc">&nbsp;            var10002[9] = &quot;&quot;;</b>
&nbsp;            var10002[10] = &quot;Underlying exception : &quot; + generationFailed;
<b class="nc">&nbsp;            throw new MockitoException(StringUtil.join(var10002), generationFailed);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public MockHandler getHandler(Object mock) {
&nbsp;        MockMethodInterceptor interceptor;
&nbsp;        if (mock instanceof Class) {
<b class="nc">&nbsp;            Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = (Map)this.mockedStatics.get();</b>
&nbsp;            interceptor = interceptors != null ? (MockMethodInterceptor)interceptors.get(mock) : null;
&nbsp;        } else {
&nbsp;            interceptor = (MockMethodInterceptor)this.mocks.get(mock);
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        return interceptor == null ? null : interceptor.handler;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {</b>
<b class="nc">&nbsp;        MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(newHandler, settings);</b>
<b class="nc">&nbsp;        if (mock instanceof Class) {</b>
<b class="nc">&nbsp;            Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = (Map)this.mockedStatics.get();</b>
&nbsp;            if (interceptors == null || !interceptors.containsKey(mock)) {
<b class="nc">&nbsp;                throw new MockitoException(&quot;Cannot reset &quot; + mock + &quot; which is not currently registered as a static mock&quot;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            interceptors.put((Class)mock, mockMethodInterceptor);
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            if (!this.mocks.containsKey(mock)) {</b>
&nbsp;                throw new MockitoException(&quot;Cannot reset &quot; + mock + &quot; which is not currently registered as a mock&quot;);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            this.mocks.put(mock, mockMethodInterceptor);
<b class="nc">&nbsp;            if (mock instanceof MockAccess) {</b>
&nbsp;                ((MockAccess)mock).setMockitoInterceptor(mockMethodInterceptor);
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            this.mocks.expungeStaleEntries();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public void clearAllCaches() {</b>
<b class="nc">&nbsp;        this.clearAllMocks();</b>
&nbsp;        this.bytecodeGenerator.clearAllCaches();
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public void clearMock(Object mock) {
<b class="nc">&nbsp;        if (mock instanceof Class) {</b>
&nbsp;            Iterator var2 = this.mockedStatics.getBackingMap().target.values().iterator();
<b class="nc">&nbsp;</b>
&nbsp;            while(var2.hasNext()) {
<b class="nc">&nbsp;                Map&lt;Class&lt;?&gt;, ?&gt; entry = (Map)var2.next();</b>
<b class="nc">&nbsp;                entry.remove(mock);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            this.mocks.remove(mock);</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public void clearAllMocks() {</b>
<b class="nc">&nbsp;        this.mockedStatics.getBackingMap().clear();</b>
&nbsp;        this.mocks.clear();
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public MockMaker.TypeMockability isTypeMockable(final Class&lt;?&gt; type) {</b>
<b class="nc">&nbsp;        return new MockMaker.TypeMockability() {</b>
<b class="nc">&nbsp;            public boolean mockable() {</b>
<b class="nc">&nbsp;                return InlineDelegateByteBuddyMockMaker.INSTRUMENTATION.isModifiableClass(type) &amp;&amp; !InlineBytecodeGenerator.EXCLUDES.contains(type);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public String nonMockableReason() {
<b class="nc">&nbsp;                if (this.mockable()) {</b>
&nbsp;                    return &quot;&quot;;
&nbsp;                } else if (type.isPrimitive()) {
&nbsp;                    return &quot;primitive type&quot;;
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    return InlineBytecodeGenerator.EXCLUDES.contains(type) ? &quot;Cannot mock wrapper types, String.class or Class.class&quot; : &quot;VM does not support modification of given type&quot;;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        };
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public &lt;T&gt; MockMaker.StaticMockControl&lt;T&gt; createStaticMock(Class&lt;T&gt; type, MockCreationSettings&lt;T&gt; settings, MockHandler handler) {
&nbsp;        if (type == ConcurrentHashMap.class) {
&nbsp;            throw new MockitoException(&quot;It is not possible to mock static methods of ConcurrentHashMap to avoid infinitive loops within Mockito&#39;s implementation of static mock handling&quot;);
&nbsp;        } else if (type != Thread.class &amp;&amp; type != System.class &amp;&amp; type != Arrays.class &amp;&amp; !ClassLoader.class.isAssignableFrom(type)) {
&nbsp;            this.bytecodeGenerator.mockClassStatic(type);
&nbsp;            Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = (Map)this.mockedStatics.get();
&nbsp;            if (interceptors == null) {
<b class="fc">&nbsp;                interceptors = new WeakHashMap();</b>
&nbsp;                this.mockedStatics.set(interceptors);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            this.mockedStatics.getBackingMap().expungeStaleEntries();</b>
&nbsp;            return new InlineStaticMockControl(type, (Map)interceptors, settings, handler);
&nbsp;        } else {
&nbsp;            throw new MockitoException(&quot;It is not possible to mock static methods of &quot; + type.getName() + &quot; to avoid interfering with class loading what leads to infinite loops&quot;);
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public &lt;T&gt; MockMaker.ConstructionMockControl&lt;T&gt; createConstructionMock(Class&lt;T&gt; type, Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory, Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory, MockedConstruction.MockInitializer&lt;T&gt; mockInitializer) {</b>
&nbsp;        if (type == Object.class) {
<b class="nc">&nbsp;            throw new MockitoException(&quot;It is not possible to mock construction of the Object class to avoid inference with default object constructor chains&quot;);</b>
&nbsp;        } else if (!type.isPrimitive() &amp;&amp; !Modifier.isAbstract(type.getModifiers())) {
<b class="nc">&nbsp;            this.bytecodeGenerator.mockClassConstruction(type);</b>
&nbsp;            Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors = (Map)this.mockedConstruction.get();
<b class="nc">&nbsp;            if (interceptors == null) {</b>
<b class="nc">&nbsp;                interceptors = new WeakHashMap();</b>
&nbsp;                this.mockedConstruction.set(interceptors);
&nbsp;            }
&nbsp;
&nbsp;            this.mockedConstruction.getBackingMap().expungeStaleEntries();
&nbsp;            return new InlineConstructionMockControl(type, settingsFactory, handlerFactory, mockInitializer, (Map)interceptors);
&nbsp;        } else {
<b class="fc">&nbsp;            throw new MockitoException(&quot;It is not possible to construct primitive types or abstract types: &quot; + type.getName());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="pc">&nbsp;    public &lt;T&gt; T newInstance(Class&lt;T&gt; cls) throws InstantiationException {</b>
<b class="nc">&nbsp;        Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors();</b>
&nbsp;        if (constructors.length == 0) {
<b class="nc">&nbsp;            throw new InstantiationException(cls.getName() + &quot; does not define a constructor&quot;);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            Constructor&lt;?&gt; selected = constructors[0];</b>
&nbsp;            Constructor[] var4 = constructors;
&nbsp;            int var5 = constructors.length;
&nbsp;
&nbsp;            int index;
<b class="fc">&nbsp;            for(index = 0; index &lt; var5; ++index) {</b>
<b class="nc">&nbsp;                Constructor&lt;?&gt; constructor = var4[index];</b>
<b class="nc">&nbsp;                if (Modifier.isPublic(constructor.getModifiers())) {</b>
<b class="nc">&nbsp;                    selected = constructor;</b>
&nbsp;                    break;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="fc">&nbsp;            Class&lt;?&gt;[] types = selected.getParameterTypes();</b>
&nbsp;            Object[] arguments = new Object[types.length];
<b class="fc">&nbsp;            index = 0;</b>
&nbsp;            Class[] var14 = types;
<b class="fc">&nbsp;            int var8 = types.length;</b>
<b class="pc">&nbsp;</b>
<b class="fc">&nbsp;            for(int var9 = 0; var9 &lt; var8; ++var9) {</b>
&nbsp;                Class&lt;?&gt; type = var14[var9];
<b class="fc">&nbsp;                arguments[index++] = this.makeStandardArgument(type);</b>
<b class="fc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            MemberAccessor accessor = Plugins.getMemberAccessor();</b>
<b class="nc">&nbsp;</b>
&nbsp;            try {
&nbsp;                return accessor.newInstance(selected, (callback) -&gt; {
&nbsp;                    this.mockitoConstruction.set(true);
&nbsp;
&nbsp;                    Object var2;
&nbsp;                    try {
<b class="fc">&nbsp;                        var2 = callback.newInstance();</b>
<b class="fc">&nbsp;                    } finally {</b>
<b class="fc">&nbsp;                        this.mockitoConstruction.set(false);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    return var2;</b>
<b class="fc">&nbsp;                }, arguments);</b>
<b class="nc">&nbsp;            } catch (Exception var11) {</b>
<b class="nc">&nbsp;                throw new InstantiationException(&quot;Could not instantiate &quot; + cls.getName(), var11);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Object makeStandardArgument(Class&lt;?&gt; type) {
<b class="nc">&nbsp;        if (type == Boolean.TYPE) {</b>
<b class="nc">&nbsp;            return false;</b>
<b class="nc">&nbsp;        } else if (type == Byte.TYPE) {</b>
&nbsp;            return 0;
&nbsp;        } else if (type == Short.TYPE) {
<b class="nc">&nbsp;            return Short.valueOf((short)0);</b>
<b class="nc">&nbsp;        } else if (type == Character.TYPE) {</b>
<b class="nc">&nbsp;            return &#39;\u0000&#39;;</b>
<b class="nc">&nbsp;        } else if (type == Integer.TYPE) {</b>
&nbsp;            return 0;
&nbsp;        } else if (type == Long.TYPE) {
&nbsp;            return 0L;
&nbsp;        } else if (type == Float.TYPE) {
&nbsp;            return 0.0F;
&nbsp;        } else {
&nbsp;            return type == Double.TYPE ? 0.0 : null;
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    static {</b>
<b class="nc">&nbsp;        Throwable initializationError = null;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        Instrumentation instrumentation;</b>
&nbsp;        try {
&nbsp;            try {
&nbsp;                instrumentation = ByteBuddyAgent.install();
&nbsp;                if (!instrumentation.isRetransformClassesSupported()) {
&nbsp;                    throw new IllegalStateException(StringUtil.join(new Object[]{&quot;Byte Buddy requires retransformation for creating inline mocks. This feature is unavailable on the current VM.&quot;, &quot;&quot;, &quot;You cannot use this mock maker on this VM&quot;}));
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                File boot = File.createTempFile(&quot;mockitoboot&quot;, &quot;.jar&quot;);</b>
<b class="nc">&nbsp;                boot.deleteOnExit();</b>
<b class="nc">&nbsp;                JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));</b>
&nbsp;
&nbsp;                try {
&nbsp;                    String source = &quot;org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher&quot;;
<b class="nc">&nbsp;                    InputStream inputStream = InlineDelegateByteBuddyMockMaker.class.getClassLoader().getResourceAsStream(source + &quot;.raw&quot;);</b>
&nbsp;                    if (inputStream == null) {
&nbsp;                        throw new IllegalStateException(StringUtil.join(new Object[]{&quot;The MockMethodDispatcher class file is not locatable: &quot; + source + &quot;.raw&quot;, &quot;&quot;, &quot;The class loader responsible for looking up the resource: &quot; + InlineDelegateByteBuddyMockMaker.class.getClassLoader()}));
&nbsp;                    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    outputStream.putNextEntry(new JarEntry(source + &quot;.class&quot;));</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    try {</b>
&nbsp;                        byte[] buffer = new byte[1024];
&nbsp;
&nbsp;                        int length;
&nbsp;                        while((length = inputStream.read(buffer)) != -1) {
&nbsp;                            outputStream.write(buffer, 0, length);
&nbsp;                        }
&nbsp;                    } finally {
&nbsp;                        inputStream.close();
&nbsp;                    }
&nbsp;
&nbsp;                    outputStream.closeEntry();
<b class="nc">&nbsp;                } finally {</b>
<b class="nc">&nbsp;                    outputStream.close();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                JarFile jarfile = new JarFile(boot);</b>
&nbsp;
<b class="nc">&nbsp;                try {</b>
<b class="nc">&nbsp;                    instrumentation.appendToBootstrapClassLoaderSearch(jarfile);</b>
&nbsp;                } catch (Throwable var26) {
<b class="nc">&nbsp;                    try {</b>
&nbsp;                        jarfile.close();
&nbsp;                    } catch (Throwable var24) {
&nbsp;                        var26.addSuppressed(var24);
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    throw var26;</b>
&nbsp;                }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                jarfile.close();</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                try {</b>
&nbsp;                    Class.forName(&quot;org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher&quot;, false, (ClassLoader)null);
&nbsp;                } catch (ClassNotFoundException var25) {
&nbsp;                    ClassNotFoundException cnfe = var25;
&nbsp;                    throw new IllegalStateException(StringUtil.join(new Object[]{&quot;Mockito failed to inject the MockMethodDispatcher class into the bootstrap class loader&quot;, &quot;&quot;, &quot;It seems like your current VM does not support the instrumentation API correctly.&quot;}), cnfe);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (IOException var29) {</b>
<b class="nc">&nbsp;                IOException ioe = var29;</b>
<b class="nc">&nbsp;                throw new IllegalStateException(StringUtil.join(new Object[]{&quot;Mockito could not self-attach a Java agent to the current VM. This feature is required for inline mocking.&quot;, &quot;This error occured due to an I/O error during the creation of this agent: &quot; + ioe, &quot;&quot;, &quot;Potentially, the current VM does not support the instrumentation API correctly&quot;}), ioe);</b>
&nbsp;            }
&nbsp;        } catch (Throwable var30) {
<b class="nc">&nbsp;            Throwable throwable = var30;</b>
<b class="nc">&nbsp;            instrumentation = null;</b>
<b class="nc">&nbsp;            initializationError = throwable;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        INSTRUMENTATION = instrumentation;
<b class="nc">&nbsp;        INITIALIZATION_ERROR = initializationError;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class InlineConstructionMockContext implements MockedConstruction.Context {
<b class="nc">&nbsp;        private static final Map&lt;String, Class&lt;?&gt;&gt; PRIMITIVES = new HashMap();</b>
<b class="nc">&nbsp;        private int count;</b>
<b class="nc">&nbsp;        private final Object[] arguments;</b>
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;        private final String[] parameterTypeNames;
&nbsp;
<b class="nc">&nbsp;        private InlineConstructionMockContext(Object[] arguments, Class&lt;?&gt; type, String[] parameterTypeNames) {</b>
<b class="nc">&nbsp;            this.arguments = arguments;</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.parameterTypeNames = parameterTypeNames;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public int getCount() {
<b class="nc">&nbsp;            if (this.count == 0) {</b>
&nbsp;                throw new MockitoConfigurationException(&quot;mocked construction context is not initialized&quot;);
&nbsp;            } else {
&nbsp;                return this.count;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public Constructor&lt;?&gt; constructor() {
&nbsp;            Class&lt;?&gt;[] parameterTypes = new Class[this.parameterTypeNames.length];
&nbsp;            int index = 0;
<b class="fc">&nbsp;            String[] var3 = this.parameterTypeNames;</b>
&nbsp;            int var4 = var3.length;
&nbsp;
<b class="pc">&nbsp;            for(int var5 = 0; var5 &lt; var4; ++var5) {</b>
&nbsp;                String parameterTypeName = var3[var5];
&nbsp;                if (PRIMITIVES.containsKey(parameterTypeName)) {
&nbsp;                    parameterTypes[index++] = (Class)PRIMITIVES.get(parameterTypeName);
&nbsp;                } else {
<b class="nc">&nbsp;                    try {</b>
<b class="nc">&nbsp;                        parameterTypes[index++] = Class.forName(parameterTypeName, false, this.type.getClassLoader());</b>
&nbsp;                    } catch (ClassNotFoundException var9) {
<b class="nc">&nbsp;                        ClassNotFoundException e = var9;</b>
<b class="nc">&nbsp;                        throw new MockitoException(&quot;Could not find parameter of type &quot; + parameterTypeName, e);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            try {</b>
&nbsp;                return this.type.getDeclaredConstructor(parameterTypes);
&nbsp;            } catch (NoSuchMethodException var8) {
&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;Could not resolve constructor of type&quot;, &quot;&quot;, this.type.getName(), &quot;&quot;, &quot;with arguments of types&quot;, Arrays.toString(parameterTypes)}), var8);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;?&gt; arguments() {
<b class="nc">&nbsp;            return Collections.unmodifiableList(Arrays.asList(this.arguments));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        static {
<b class="nc">&nbsp;            PRIMITIVES.put(Boolean.TYPE.getName(), Boolean.TYPE);</b>
&nbsp;            PRIMITIVES.put(Byte.TYPE.getName(), Byte.TYPE);
&nbsp;            PRIMITIVES.put(Short.TYPE.getName(), Short.TYPE);
<b class="nc">&nbsp;            PRIMITIVES.put(Character.TYPE.getName(), Character.TYPE);</b>
<b class="nc">&nbsp;            PRIMITIVES.put(Integer.TYPE.getName(), Integer.TYPE);</b>
&nbsp;            PRIMITIVES.put(Long.TYPE.getName(), Long.TYPE);
<b class="nc">&nbsp;            PRIMITIVES.put(Float.TYPE.getName(), Float.TYPE);</b>
&nbsp;            PRIMITIVES.put(Double.TYPE.getName(), Double.TYPE);
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    private class InlineConstructionMockControl&lt;T&gt; implements MockMaker.ConstructionMockControl&lt;T&gt; {
<b class="nc">&nbsp;        private final Class&lt;T&gt; type;</b>
<b class="nc">&nbsp;        private final Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory;</b>
<b class="nc">&nbsp;        private final Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory;</b>
<b class="nc">&nbsp;        private final MockedConstruction.MockInitializer&lt;T&gt; mockInitializer;</b>
&nbsp;        private final Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors;
<b class="nc">&nbsp;        private final List&lt;Object&gt; all = new ArrayList();</b>
&nbsp;        private int count;
<b class="nc">&nbsp;</b>
&nbsp;        private InlineConstructionMockControl(Class&lt;T&gt; type, Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory, Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory, MockedConstruction.MockInitializer&lt;T&gt; mockInitializer, Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors) {
&nbsp;            this.type = type;
&nbsp;            this.settingsFactory = settingsFactory;
&nbsp;            this.handlerFactory = handlerFactory;
&nbsp;            this.mockInitializer = mockInitializer;
&nbsp;            this.interceptors = interceptors;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public Class&lt;T&gt; getType() {</b>
<b class="nc">&nbsp;            return this.type;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public void enable() {</b>
<b class="nc">&nbsp;            if (this.interceptors.putIfAbsent(this.type, (object, context) -&gt; {</b>
&nbsp;                ((InlineConstructionMockContext)context).count = ++this.count;
<b class="nc">&nbsp;                MockMethodInterceptor interceptor = new MockMethodInterceptor((MockHandler)this.handlerFactory.apply(context), (MockCreationSettings)this.settingsFactory.apply(context));</b>
&nbsp;                InlineDelegateByteBuddyMockMaker.this.mocks.put(object, interceptor);
&nbsp;
<b class="nc">&nbsp;                try {</b>
&nbsp;                    this.mockInitializer.prepare(object, context);
<b class="nc">&nbsp;                } catch (Throwable var5) {</b>
<b class="nc">&nbsp;                    Throwable t = var5;</b>
<b class="nc">&nbsp;                    InlineDelegateByteBuddyMockMaker.this.mocks.remove(object);</b>
<b class="nc">&nbsp;                    throw new MockitoException(&quot;Could not initialize mocked construction&quot;, t);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                this.all.add(object);</b>
&nbsp;            }) != null) {
<b class="nc">&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;For &quot; + this.type.getName() + &quot;, static mocking is already registered in the current thread&quot;, &quot;&quot;, &quot;To create a new mock, the existing static mock registration must be deregistered&quot;}));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void disable() {
&nbsp;            if (this.interceptors.remove(this.type) == null) {
&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;Could not deregister &quot; + this.type.getName() + &quot; as a static mock since it is not currently registered&quot;, &quot;&quot;, &quot;To register a static mock, use Mockito.mockStatic(&quot; + this.type.getSimpleName() + &quot;.class)&quot;}));
<b class="fc">&nbsp;            } else {</b>
<b class="pc">&nbsp;                this.all.clear();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;        public List&lt;T&gt; getMocks() {</b>
<b class="pc">&nbsp;            return this.all;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private static class InlineStaticMockControl&lt;T&gt; implements MockMaker.StaticMockControl&lt;T&gt; {
<b class="fc">&nbsp;        private final Class&lt;T&gt; type;</b>
<b class="fc">&nbsp;        private final Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors;</b>
<b class="fc">&nbsp;        private final MockCreationSettings&lt;T&gt; settings;</b>
<b class="pc">&nbsp;        private final MockHandler handler;</b>
<b class="nc">&nbsp;</b>
&nbsp;        private InlineStaticMockControl(Class&lt;T&gt; type, Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors, MockCreationSettings&lt;T&gt; settings, MockHandler handler) {
<b class="fc">&nbsp;            this.type = type;</b>
&nbsp;            this.interceptors = interceptors;
<b class="fc">&nbsp;            this.settings = settings;</b>
<b class="fc">&nbsp;            this.handler = handler;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Class&lt;T&gt; getType() {</b>
&nbsp;            return this.type;
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        public void enable() {</b>
<b class="nc">&nbsp;            if (this.interceptors.putIfAbsent(this.type, new MockMethodInterceptor(this.handler, this.settings)) != null) {</b>
&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;For &quot; + this.type.getName() + &quot;, static mocking is already registered in the current thread&quot;, &quot;&quot;, &quot;To create a new mock, the existing static mock registration must be deregistered&quot;}));
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public void disable() {
&nbsp;            if (this.interceptors.remove(this.type) == null) {
&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;Could not deregister &quot; + this.type.getName() + &quot; as a static mock since it is not currently registered&quot;, &quot;&quot;, &quot;To register a static mock, use Mockito.mockStatic(&quot; + this.type.getSimpleName() + &quot;.class)&quot;}));
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-05-14 20:57</div>
</div>
</body>
</html>
