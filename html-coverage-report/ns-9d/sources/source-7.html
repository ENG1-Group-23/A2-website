


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MockMethodAdvice</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.mockito.internal.creation.bytebuddy</a>
</div>

<h1>Coverage Summary for Class: MockMethodAdvice (org.mockito.internal.creation.bytebuddy)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MockMethodAdvice</td>
<td class="coverageStat">
  <span class="percent">
    7.7%
  </span>
  <span class="absValue">
    (1/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.3%
  </span>
  <span class="absValue">
    (10/81)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MockMethodAdvice$ConstructorShortcut</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7%
  </span>
  <span class="absValue">
    (3/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ConstructorShortcut$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/154)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ForEquals</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ForHashCode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ForReadObject</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ForStatic</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$Identifier</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$SelfCallInfo</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (1/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    9.1%
  </span>
  <span class="absValue">
    (3/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/138)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.5%
  </span>
  <span class="absValue">
    (14/313)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.mockito.internal.creation.bytebuddy;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Retention;
&nbsp;import java.lang.annotation.RetentionPolicy;
&nbsp;import java.lang.ref.SoftReference;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.IntStream;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.Advice;
&nbsp;import net.bytebuddy.asm.AsmVisitorWrapper;
&nbsp;import net.bytebuddy.asm.Advice.AllArguments;
&nbsp;import net.bytebuddy.asm.Advice.Enter;
&nbsp;import net.bytebuddy.asm.Advice.OnMethodEnter;
&nbsp;import net.bytebuddy.asm.Advice.OnMethodExit;
&nbsp;import net.bytebuddy.asm.Advice.Origin;
&nbsp;import net.bytebuddy.asm.Advice.Return;
&nbsp;import net.bytebuddy.asm.Advice.This;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.bind.annotation.Argument;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;
&nbsp;import net.bytebuddy.jar.asm.Label;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import org.mockito.exceptions.base.MockitoException;
&nbsp;import org.mockito.internal.configuration.plugins.Plugins;
&nbsp;import org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher;
&nbsp;import org.mockito.internal.debugging.LocationFactory;
&nbsp;import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
&nbsp;import org.mockito.internal.invocation.RealMethod;
&nbsp;import org.mockito.internal.invocation.SerializableMethod;
&nbsp;import org.mockito.internal.invocation.mockref.MockReference;
&nbsp;import org.mockito.internal.invocation.mockref.MockWeakReference;
&nbsp;import org.mockito.internal.util.concurrent.DetachedThreadLocal;
&nbsp;import org.mockito.internal.util.concurrent.WeakConcurrentMap;
&nbsp;import org.mockito.plugins.MemberAccessor;
&nbsp;
&nbsp;public class MockMethodAdvice extends MockMethodDispatcher {
&nbsp;    private final WeakConcurrentMap&lt;Object, MockMethodInterceptor&gt; interceptors;
<b class="fc">&nbsp;    private final DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt;&gt; mockedStatics;</b>
<b class="fc">&nbsp;    private final String identifier;</b>
<b class="fc">&nbsp;    private final SelfCallInfo selfCallInfo = new SelfCallInfo();</b>
&nbsp;    private final MethodGraph.Compiler compiler = Default.forJavaHierarchy();
&nbsp;    private final WeakConcurrentMap&lt;Class&lt;?&gt;, SoftReference&lt;MethodGraph&gt;&gt; graphs = new WeakConcurrentMap.WithInlinedExpunction();
&nbsp;    private final Predicate&lt;Class&lt;?&gt;&gt; isMockConstruction;
&nbsp;    private final ConstructionCallback onConstruction;
&nbsp;
&nbsp;    public MockMethodAdvice(WeakConcurrentMap&lt;Object, MockMethodInterceptor&gt; interceptors, DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt;&gt; mockedStatics, String identifier, Predicate&lt;Class&lt;?&gt;&gt; isMockConstruction, ConstructionCallback onConstruction) {
&nbsp;        this.interceptors = interceptors;
&nbsp;        this.mockedStatics = mockedStatics;
&nbsp;        this.onConstruction = onConstruction;
&nbsp;        this.identifier = identifier;
<b class="fc">&nbsp;        this.isMockConstruction = isMockConstruction;</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    @OnMethodEnter(</b>
<b class="fc">&nbsp;        skipOn = Advice.OnNonDefaultValue.class</b>
<b class="fc">&nbsp;    )</b>
<b class="fc">&nbsp;    private static Callable&lt;?&gt; enter(@MockMethodAdvice.Identifier String identifier, @This Object mock, @Origin Method origin, @AllArguments Object[] arguments) throws Throwable {</b>
&nbsp;        MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, mock);
&nbsp;        return dispatcher != null &amp;&amp; dispatcher.isMocked(mock) &amp;&amp; !dispatcher.isOverridden(mock, origin) ? dispatcher.handle(mock, origin, arguments) : null;
&nbsp;    }
&nbsp;
&nbsp;    @OnMethodExit
&nbsp;    private static void exit(@Return(readOnly = false,typing = Typing.DYNAMIC) Object returned, @Enter Callable&lt;?&gt; mocked) throws Throwable {
&nbsp;        if (mocked != null) {
&nbsp;            returned = mocked.call();
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public Callable&lt;?&gt; handle(Object instance, Method origin, Object[] arguments) throws Throwable {</b>
<b class="nc">&nbsp;        MockMethodInterceptor interceptor = (MockMethodInterceptor)this.interceptors.get(instance);</b>
&nbsp;        if (interceptor == null) {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } else {
&nbsp;            Object realMethod;
&nbsp;            if (instance instanceof Serializable) {
&nbsp;                realMethod = new SerializableRealMethodCall(this.identifier, origin, instance, arguments);
&nbsp;            } else {
&nbsp;                realMethod = new RealMethodCall(this.selfCallInfo, origin, instance, arguments);
&nbsp;            }
&nbsp;
&nbsp;            return new ReturnValueWrapper(interceptor.doIntercept(instance, origin, arguments, (RealMethod)realMethod, LocationFactory.create(true)));
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public Callable&lt;?&gt; handleStatic(Class&lt;?&gt; type, Method origin, Object[] arguments) throws Throwable {</b>
&nbsp;        Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = (Map)this.mockedStatics.get();
&nbsp;        return interceptors != null &amp;&amp; interceptors.containsKey(type) ? new ReturnValueWrapper(((MockMethodInterceptor)interceptors.get(type)).doIntercept(type, origin, arguments, new StaticMethodCall(this.selfCallInfo, type, origin, arguments), LocationFactory.create(true))) : null;
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public Object handleConstruction(Class&lt;?&gt; type, Object object, Object[] arguments, String[] parameterTypeNames) {</b>
<b class="nc">&nbsp;        return this.onConstruction.apply(type, object, arguments, parameterTypeNames);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public boolean isMock(Object instance) {</b>
<b class="nc">&nbsp;        return instance != this.interceptors.target &amp;&amp; this.interceptors.containsKey(instance);</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public boolean isMocked(Object instance) {
<b class="nc">&nbsp;        return this.selfCallInfo.checkSelfCall(instance) &amp;&amp; this.isMock(instance);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public boolean isMockedStatic(Class&lt;?&gt; type) {
&nbsp;        if (!this.selfCallInfo.checkSelfCall(type)) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            Map&lt;Class&lt;?&gt;, ?&gt; interceptors = (Map)this.mockedStatics.get();
<b class="nc">&nbsp;            return interceptors != null &amp;&amp; interceptors.containsKey(type);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public boolean isOverridden(Object instance, Method origin) {</b>
&nbsp;        SoftReference&lt;MethodGraph&gt; reference = (SoftReference)this.graphs.get(instance.getClass());
<b class="nc">&nbsp;        MethodGraph methodGraph = reference == null ? null : (MethodGraph)reference.get();</b>
<b class="nc">&nbsp;        if (methodGraph == null) {</b>
&nbsp;            methodGraph = this.compiler.compile(ForLoadedType.of(instance.getClass()));
&nbsp;            this.graphs.put(instance.getClass(), new SoftReference(methodGraph));
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        MethodGraph.Node node = ((MethodGraph)methodGraph).locate((new MethodDescription.ForLoadedMethod(origin)).asSignatureToken());</b>
&nbsp;        return !node.getSort().isResolved() || !((MethodDescription.InDefinedShape)node.getRepresentative().asDefined()).getDeclaringType().represents(origin.getDeclaringClass());
&nbsp;    }
&nbsp;
&nbsp;    public boolean isConstructorMock(Class&lt;?&gt; type) {
&nbsp;        return this.isMockConstruction.test(type);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private static Object tryInvoke(Method origin, Object instance, Object[] arguments) throws Throwable {
&nbsp;        MemberAccessor accessor = Plugins.getMemberAccessor();
&nbsp;
&nbsp;        try {
&nbsp;            return accessor.invoke(origin, instance, arguments);
<b class="nc">&nbsp;        } catch (InvocationTargetException var6) {</b>
&nbsp;            InvocationTargetException exception = var6;
&nbsp;            Throwable cause = exception.getCause();
&nbsp;            (new ConditionalStackTraceFilter()).filter(removeRecursiveCalls(cause, origin.getDeclaringClass()));
&nbsp;            throw cause;
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    static Throwable removeRecursiveCalls(Throwable cause, Class&lt;?&gt; declaringClass) {
&nbsp;        List&lt;String&gt; uniqueStackTraceItems = new ArrayList();
<b class="nc">&nbsp;        List&lt;Integer&gt; indexesToBeRemoved = new ArrayList();</b>
<b class="nc">&nbsp;        StackTraceElement[] var4 = cause.getStackTrace();</b>
&nbsp;        int var5 = var4.length;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        for(int var6 = 0; var6 &lt; var5; ++var6) {</b>
&nbsp;            StackTraceElement element = var4[var6];
&nbsp;            String var10000 = element.getClassName();
&nbsp;            String key = var10000 + element.getLineNumber();
&nbsp;            int elementIndex = uniqueStackTraceItems.lastIndexOf(key);
<b class="nc">&nbsp;            uniqueStackTraceItems.add(key);</b>
<b class="nc">&nbsp;            if (elementIndex &gt; -1 &amp;&amp; declaringClass.getName().equals(element.getClassName())) {</b>
<b class="nc">&nbsp;                indexesToBeRemoved.add(elementIndex);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        List&lt;StackTraceElement&gt; adjustedList = new ArrayList(Arrays.asList(cause.getStackTrace()));</b>
&nbsp;        IntStream var11 = indexesToBeRemoved.stream().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue);
<b class="nc">&nbsp;        Objects.requireNonNull(adjustedList);</b>
<b class="nc">&nbsp;        var11.forEach(adjustedList::remove);</b>
<b class="nc">&nbsp;        cause.setStackTrace((StackTraceElement[])adjustedList.toArray(new StackTraceElement[0]));</b>
<b class="nc">&nbsp;        return cause;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static class ForReadObject {</b>
<b class="nc">&nbsp;        public ForReadObject() {</b>
&nbsp;        }
&nbsp;
&nbsp;        public static void doReadObject(@MockMethodAdvice.Identifier String identifier, @net.bytebuddy.implementation.bind.annotation.This MockAccess thiz, @Argument(0) ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
&nbsp;            objectInputStream.defaultReadObject();
<b class="nc">&nbsp;            MockMethodAdvice mockMethodAdvice = (MockMethodAdvice)MockMethodDispatcher.get(identifier, thiz);</b>
&nbsp;            if (mockMethodAdvice != null) {
&nbsp;                mockMethodAdvice.interceptors.put(thiz, thiz.getMockitoInterceptor());
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class ForStatic {
&nbsp;        ForStatic() {
&nbsp;        }
&nbsp;
&nbsp;        @OnMethodEnter(
&nbsp;            skipOn = Advice.OnNonDefaultValue.class
&nbsp;        )
&nbsp;        private static Callable&lt;?&gt; enter(@MockMethodAdvice.Identifier String identifier, @Origin Class&lt;?&gt; type, @Origin Method origin, @AllArguments Object[] arguments) throws Throwable {
&nbsp;            MockMethodDispatcher dispatcher = MockMethodDispatcher.getStatic(identifier, type);
&nbsp;            return dispatcher != null &amp;&amp; dispatcher.isMockedStatic(type) ? dispatcher.handleStatic(type, origin, arguments) : null;
&nbsp;        }
&nbsp;
&nbsp;        @OnMethodExit
&nbsp;        private static void exit(@Return(readOnly = false,typing = Typing.DYNAMIC) Object returned, @Enter Callable&lt;?&gt; mocked) throws Throwable {
&nbsp;            if (mocked != null) {
&nbsp;                returned = mocked.call();
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class ForEquals {
&nbsp;        ForEquals() {
&nbsp;        }
&nbsp;
&nbsp;        @OnMethodEnter(
&nbsp;            skipOn = Advice.OnNonDefaultValue.class
&nbsp;        )
&nbsp;        private static boolean enter(@MockMethodAdvice.Identifier String identifier, @This Object self) {
&nbsp;            MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, self);
&nbsp;            return dispatcher != null &amp;&amp; dispatcher.isMock(self);
&nbsp;        }
&nbsp;
&nbsp;        @OnMethodExit
&nbsp;        private static void enter(@This Object self, @net.bytebuddy.asm.Advice.Argument(0) Object other, @Return(readOnly = false) boolean equals, @Enter boolean skipped) {
&nbsp;            if (skipped) {
&nbsp;                boolean var10000 = self == other;
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class ForHashCode {
&nbsp;        ForHashCode() {
&nbsp;        }
&nbsp;
&nbsp;        @OnMethodEnter(
&nbsp;            skipOn = Advice.OnNonDefaultValue.class
&nbsp;        )
&nbsp;        private static boolean enter(@MockMethodAdvice.Identifier String id, @This Object self) {
&nbsp;            MockMethodDispatcher dispatcher = MockMethodDispatcher.get(id, self);
&nbsp;            return dispatcher != null &amp;&amp; dispatcher.isMock(self);
&nbsp;        }
&nbsp;
&nbsp;        @OnMethodExit
&nbsp;        private static void enter(@This Object self, @Return(readOnly = false) int hashCode, @Enter boolean skipped) {
&nbsp;            if (skipped) {
&nbsp;                hashCode = System.identityHashCode(self);
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @interface Identifier {
&nbsp;    }
&nbsp;
&nbsp;    static class ConstructorShortcut implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper {
&nbsp;        private final String identifier;
&nbsp;
&nbsp;        ConstructorShortcut(String identifier) {
&nbsp;            this.identifier = identifier;
&nbsp;        }
&nbsp;
&nbsp;        public MethodVisitor wrap(final TypeDescription instrumentedType, final MethodDescription instrumentedMethod, MethodVisitor methodVisitor, final Implementation.Context implementationContext, TypePool typePool, int writerFlags, int readerFlags) {
&nbsp;            if (instrumentedMethod.isConstructor() &amp;&amp; !instrumentedType.represents(Object.class)) {
&nbsp;                MethodList&lt;MethodDescription.InDefinedShape&gt; constructors = (MethodList)instrumentedType.getSuperClass().asErasure().getDeclaredMethods().filter(ElementMatchers.isConstructor().and(ElementMatchers.not(ElementMatchers.isPrivate())));
&nbsp;                int arguments = Integer.MAX_VALUE;
&nbsp;                boolean packagePrivate = true;
&nbsp;                MethodDescription.InDefinedShape current = null;
&nbsp;                Iterator var12 = constructors.iterator();
&nbsp;
&nbsp;                while(true) {
&nbsp;                    MethodDescription.InDefinedShape constructor;
&nbsp;                    do {
&nbsp;                        do {
&nbsp;                            if (!var12.hasNext()) {
&nbsp;                                if (current != null) {
&nbsp;                                    final MethodDescription.InDefinedShape selected = current;
&nbsp;                                    return new MethodVisitor(OpenedClassReader.ASM_API, methodVisitor) {
&nbsp;                                        public void visitCode() {
&nbsp;                                            super.visitCode();
&nbsp;                                            Label label = new Label();
&nbsp;                                            super.visitLdcInsn(ConstructorShortcut.this.identifier);
&nbsp;                                            if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V5)) {
&nbsp;                                                super.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));
&nbsp;                                            } else {
&nbsp;                                                super.visitLdcInsn(instrumentedType.getName());
&nbsp;                                                super.visitMethodInsn(184, Type.getInternalName(Class.class), &quot;forName&quot;, Type.getMethodDescriptor(Type.getType(Class.class), new Type[]{Type.getType(String.class)}), false);
<b class="nc">&nbsp;                                            }</b>
&nbsp;
<b class="nc">&nbsp;                                            super.visitMethodInsn(184, Type.getInternalName(MockMethodDispatcher.class), &quot;isConstructorMock&quot;, Type.getMethodDescriptor(Type.BOOLEAN_TYPE, new Type[]{Type.getType(String.class), Type.getType(Class.class)}), false);</b>
<b class="nc">&nbsp;                                            super.visitInsn(3);</b>
<b class="nc">&nbsp;                                            super.visitJumpInsn(159, label);</b>
<b class="nc">&nbsp;                                            super.visitVarInsn(25, 0);</b>
<b class="nc">&nbsp;                                            Iterator var2 = selected.getParameters().asTypeList().asErasures().iterator();</b>
<b class="nc">&nbsp;</b>
&nbsp;                                            while(true) {
&nbsp;                                                while(var2.hasNext()) {
&nbsp;                                                    TypeDescription type = (TypeDescription)var2.next();
&nbsp;                                                    if (!type.represents(Boolean.TYPE) &amp;&amp; !type.represents(Byte.TYPE) &amp;&amp; !type.represents(Short.TYPE) &amp;&amp; !type.represents(Character.TYPE) &amp;&amp; !type.represents(Integer.TYPE)) {
<b class="nc">&nbsp;                                                        if (type.represents(Long.TYPE)) {</b>
<b class="nc">&nbsp;                                                            super.visitInsn(9);</b>
<b class="nc">&nbsp;                                                        } else if (type.represents(Float.TYPE)) {</b>
<b class="nc">&nbsp;                                                            super.visitInsn(11);</b>
<b class="nc">&nbsp;                                                        } else if (type.represents(Double.TYPE)) {</b>
<b class="nc">&nbsp;                                                            super.visitInsn(14);</b>
&nbsp;                                                        } else {
<b class="nc">&nbsp;                                                            super.visitInsn(1);</b>
<b class="nc">&nbsp;                                                        }</b>
&nbsp;                                                    } else {
&nbsp;                                                        super.visitInsn(3);
<b class="nc">&nbsp;                                                    }</b>
<b class="nc">&nbsp;                                                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                                                super.visitMethodInsn(183, selected.getDeclaringType().getInternalName(), selected.getInternalName(), selected.getDescriptor(), false);</b>
<b class="nc">&nbsp;                                                super.visitLdcInsn(ConstructorShortcut.this.identifier);</b>
<b class="nc">&nbsp;                                                if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V5)) {</b>
<b class="nc">&nbsp;                                                    super.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));</b>
<b class="nc">&nbsp;                                                } else {</b>
&nbsp;                                                    super.visitLdcInsn(instrumentedType.getName());
&nbsp;                                                    super.visitMethodInsn(184, Type.getInternalName(Class.class), &quot;forName&quot;, Type.getMethodDescriptor(Type.getType(Class.class), new Type[]{Type.getType(String.class)}), false);
&nbsp;                                                }
&nbsp;
&nbsp;                                                super.visitVarInsn(25, 0);
&nbsp;                                                super.visitLdcInsn(instrumentedMethod.getParameters().size());
&nbsp;                                                super.visitTypeInsn(189, Type.getInternalName(Object.class));
&nbsp;                                                int index = 0;
&nbsp;
&nbsp;                                                Iterator var8;
&nbsp;                                                for(var8 = instrumentedMethod.getParameters().iterator(); var8.hasNext(); super.visitInsn(83)) {
&nbsp;                                                    ParameterDescription parameter = (ParameterDescription)var8.next();
&nbsp;                                                    super.visitInsn(89);
&nbsp;                                                    super.visitLdcInsn(index++);
&nbsp;                                                    Type typex = Type.getType(parameter.getType().asErasure().getDescriptor());
&nbsp;                                                    super.visitVarInsn(typex.getOpcode(21), parameter.getOffset());
<b class="fc">&nbsp;                                                    if (parameter.getType().isPrimitive()) {</b>
&nbsp;                                                        Type wrapper = Type.getType(parameter.getType().asErasure().asBoxed().getDescriptor());
&nbsp;                                                        super.visitMethodInsn(184, wrapper.getInternalName(), &quot;valueOf&quot;, Type.getMethodDescriptor(wrapper, new Type[]{typex}), false);
<b class="nc">&nbsp;                                                    }</b>
<b class="nc">&nbsp;                                                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                                                index = 0;
&nbsp;                                                super.visitLdcInsn(instrumentedMethod.getParameters().size());
&nbsp;                                                super.visitTypeInsn(189, Type.getInternalName(String.class));
<b class="nc">&nbsp;                                                var8 = instrumentedMethod.getParameters().asTypeList().asErasures().iterator();</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                                                while(var8.hasNext()) {</b>
&nbsp;                                                    TypeDescription typeDescription = (TypeDescription)var8.next();
<b class="nc">&nbsp;                                                    super.visitInsn(89);</b>
&nbsp;                                                    super.visitLdcInsn(index++);
&nbsp;                                                    super.visitLdcInsn(typeDescription.getName());
&nbsp;                                                    super.visitInsn(83);
&nbsp;                                                }
&nbsp;
&nbsp;                                                super.visitMethodInsn(184, Type.getInternalName(MockMethodDispatcher.class), &quot;handleConstruction&quot;, Type.getMethodDescriptor(Type.getType(Object.class), new Type[]{Type.getType(String.class), Type.getType(Class.class), Type.getType(Object.class), Type.getType(Object[].class), Type.getType(String[].class)}), false);
&nbsp;                                                FieldList&lt;FieldDescription.InDefinedShape&gt; fields = (FieldList)instrumentedType.getDeclaredFields().filter(ElementMatchers.not(ElementMatchers.isStatic()));
&nbsp;                                                super.visitTypeInsn(192, instrumentedType.getInternalName());
&nbsp;                                                super.visitInsn(89);
<b class="fc">&nbsp;                                                Label noSpy = new Label();</b>
<b class="fc">&nbsp;                                                super.visitJumpInsn(198, noSpy);</b>
<b class="fc">&nbsp;                                                Iterator var12 = fields.iterator();</b>
&nbsp;
&nbsp;                                                while(var12.hasNext()) {
&nbsp;                                                    FieldDescription field = (FieldDescription)var12.next();
&nbsp;                                                    super.visitInsn(89);
&nbsp;                                                    super.visitFieldInsn(180, instrumentedType.getInternalName(), field.getInternalName(), field.getDescriptor());
&nbsp;                                                    super.visitVarInsn(25, 0);
&nbsp;                                                    super.visitInsn(field.getType().getStackSize() == StackSize.DOUBLE ? 91 : 90);
&nbsp;                                                    super.visitInsn(87);
&nbsp;                                                    super.visitFieldInsn(181, instrumentedType.getInternalName(), field.getInternalName(), field.getDescriptor());
&nbsp;                                                }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                                                super.visitLabel(noSpy);</b>
&nbsp;                                                Object[] locals;
<b class="nc">&nbsp;                                                if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6)) {</b>
<b class="nc">&nbsp;                                                    locals = MockMethodAdvice.ConstructorShortcut.toFrames(instrumentedType.getInternalName(), instrumentedMethod.getParameters().asTypeList().asErasures());</b>
<b class="nc">&nbsp;                                                    super.visitFrame(0, locals.length, locals, 1, new Object[]{instrumentedType.getInternalName()});</b>
<b class="nc">&nbsp;                                                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                                                super.visitInsn(87);</b>
<b class="nc">&nbsp;                                                super.visitInsn(177);</b>
<b class="nc">&nbsp;                                                super.visitLabel(label);</b>
&nbsp;                                                if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6)) {
&nbsp;                                                    locals = MockMethodAdvice.ConstructorShortcut.toFrames(Opcodes.UNINITIALIZED_THIS, instrumentedMethod.getParameters().asTypeList().asErasures());
&nbsp;                                                    super.visitFrame(0, locals.length, locals, 0, new Object[0]);
<b class="nc">&nbsp;                                                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                                                return;</b>
<b class="nc">&nbsp;                                            }</b>
<b class="nc">&nbsp;                                        }</b>
&nbsp;
<b class="nc">&nbsp;                                        public void visitMaxs(int maxStack, int maxLocals) {</b>
<b class="nc">&nbsp;                                            int prequel = Math.max(5, selected.getStackSize());</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                                            for(Iterator var4 = instrumentedMethod.getParameters().iterator(); var4.hasNext(); prequel = Math.max(prequel, 8)) {</b>
&nbsp;                                                ParameterDescription parameter = (ParameterDescription)var4.next();
&nbsp;                                                prequel = Math.max(prequel, 6 + parameter.getType().getStackSize().getSize());
<b class="nc">&nbsp;                                            }</b>
&nbsp;
&nbsp;                                            super.visitMaxs(Math.max(maxStack, prequel), maxLocals);
&nbsp;                                        }
&nbsp;                                    };
&nbsp;                                }
&nbsp;
&nbsp;                                return methodVisitor;
&nbsp;                            }
&nbsp;
&nbsp;                            constructor = (MethodDescription.InDefinedShape)var12.next();
&nbsp;                        } while(constructor.getParameters().size() &gt;= arguments);
&nbsp;                    } while(!packagePrivate &amp;&amp; constructor.isPackagePrivate());
&nbsp;
&nbsp;                    arguments = constructor.getParameters().size();
&nbsp;                    packagePrivate = constructor.isPackagePrivate();
&nbsp;                    current = constructor;
&nbsp;                }
&nbsp;            } else {
&nbsp;                return methodVisitor;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private static Object[] toFrames(Object self, List&lt;TypeDescription&gt; types) {</b>
<b class="nc">&nbsp;            Object[] frames = new Object[1 + types.size()];</b>
<b class="nc">&nbsp;            frames[0] = self;</b>
&nbsp;            int index = 0;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            Object frame;</b>
&nbsp;            for(Iterator var4 = types.iterator(); var4.hasNext(); frames[index] = frame) {
<b class="nc">&nbsp;                TypeDescription type = (TypeDescription)var4.next();</b>
&nbsp;                if (!type.represents(Boolean.TYPE) &amp;&amp; !type.represents(Byte.TYPE) &amp;&amp; !type.represents(Short.TYPE) &amp;&amp; !type.represents(Character.TYPE) &amp;&amp; !type.represents(Integer.TYPE)) {
<b class="nc">&nbsp;                    if (type.represents(Long.TYPE)) {</b>
<b class="nc">&nbsp;                        frame = Opcodes.LONG;</b>
<b class="nc">&nbsp;                    } else if (type.represents(Float.TYPE)) {</b>
&nbsp;                        frame = Opcodes.FLOAT;
&nbsp;                    } else if (type.represents(Double.TYPE)) {
<b class="nc">&nbsp;                        frame = Opcodes.DOUBLE;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        frame = type.getInternalName();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    frame = Opcodes.INTEGER;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                ++index;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            return frames;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private static class SelfCallInfo extends ThreadLocal&lt;Object&gt; {</b>
<b class="nc">&nbsp;        private SelfCallInfo() {</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        Object replace(Object value) {</b>
<b class="nc">&nbsp;            Object current = this.get();</b>
<b class="nc">&nbsp;            this.set(value);</b>
<b class="nc">&nbsp;            return current;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        boolean checkSelfCall(Object value) {</b>
&nbsp;            if (value == this.get()) {
<b class="nc">&nbsp;                this.set((Object)null);</b>
&nbsp;                return false;
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    private static class ReturnValueWrapper implements Callable&lt;Object&gt; {
<b class="nc">&nbsp;        private final Object returned;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private ReturnValueWrapper(Object returned) {</b>
<b class="nc">&nbsp;            this.returned = returned;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public Object call() {</b>
<b class="nc">&nbsp;            return this.returned;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    private static class StaticMethodCall implements RealMethod {</b>
<b class="nc">&nbsp;        private final SelfCallInfo selfCallInfo;</b>
<b class="nc">&nbsp;        private final Class&lt;?&gt; type;</b>
&nbsp;        private final Method origin;
&nbsp;        private final Object[] arguments;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private StaticMethodCall(SelfCallInfo selfCallInfo, Class&lt;?&gt; type, Method origin, Object[] arguments) {</b>
<b class="nc">&nbsp;            this.selfCallInfo = selfCallInfo;</b>
<b class="nc">&nbsp;            this.type = type;</b>
<b class="nc">&nbsp;            this.origin = origin;</b>
&nbsp;            this.arguments = arguments;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isInvokable() {</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Object invoke() throws Throwable {</b>
<b class="nc">&nbsp;            this.selfCallInfo.set(this.type);</b>
<b class="nc">&nbsp;            return MockMethodAdvice.tryInvoke(this.origin, (Object)null, this.arguments);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    private static class SerializableRealMethodCall implements RealMethod {</b>
<b class="nc">&nbsp;        private final String identifier;</b>
<b class="nc">&nbsp;        private final SerializableMethod origin;</b>
<b class="nc">&nbsp;        private final MockReference&lt;Object&gt; instanceRef;</b>
<b class="nc">&nbsp;        private final Object[] arguments;</b>
&nbsp;
<b class="nc">&nbsp;        private SerializableRealMethodCall(String identifier, Method origin, Object instance, Object[] arguments) {</b>
&nbsp;            this.origin = new SerializableMethod(origin);
<b class="nc">&nbsp;            this.identifier = identifier;</b>
&nbsp;            this.instanceRef = new MockWeakReference(instance);
&nbsp;            this.arguments = arguments;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isInvokable() {</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public Object invoke() throws Throwable {
<b class="nc">&nbsp;            Method method = this.origin.getJavaMethod();</b>
<b class="nc">&nbsp;            MockMethodDispatcher mockMethodDispatcher = MockMethodDispatcher.get(this.identifier, this.instanceRef.get());</b>
<b class="nc">&nbsp;            if (!(mockMethodDispatcher instanceof MockMethodAdvice)) {</b>
<b class="nc">&nbsp;                throw new MockitoException(&quot;Unexpected dispatcher for advice-based super call&quot;);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                Object previous = ((MockMethodAdvice)mockMethodDispatcher).selfCallInfo.replace(this.instanceRef.get());</b>
<b class="nc">&nbsp;</b>
&nbsp;                Object var4;
<b class="nc">&nbsp;                try {</b>
&nbsp;                    var4 = MockMethodAdvice.tryInvoke(method, this.instanceRef.get(), this.arguments);
<b class="nc">&nbsp;                } finally {</b>
<b class="nc">&nbsp;                    ((MockMethodAdvice)mockMethodDispatcher).selfCallInfo.set(previous);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                return var4;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private static class RealMethodCall implements RealMethod {</b>
<b class="nc">&nbsp;        private final SelfCallInfo selfCallInfo;</b>
<b class="nc">&nbsp;        private final Method origin;</b>
<b class="nc">&nbsp;        private final MockWeakReference&lt;Object&gt; instanceRef;</b>
<b class="nc">&nbsp;        private final Object[] arguments;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private RealMethodCall(SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {</b>
<b class="nc">&nbsp;            this.selfCallInfo = selfCallInfo;</b>
<b class="nc">&nbsp;            this.origin = origin;</b>
&nbsp;            this.instanceRef = new MockWeakReference(instance);
<b class="nc">&nbsp;            this.arguments = arguments;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isInvokable() {</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Object invoke() throws Throwable {</b>
<b class="nc">&nbsp;            this.selfCallInfo.set(this.instanceRef.get());</b>
<b class="nc">&nbsp;            return MockMethodAdvice.tryInvoke(this.origin, this.instanceRef.get(), this.arguments);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-05-14 20:57</div>
</div>
</body>
</html>
