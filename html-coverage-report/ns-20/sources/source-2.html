


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ByteBuddyAgent</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.agent</a>
</div>

<h1>Coverage Summary for Class: ByteBuddyAgent (net.bytebuddy.agent)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ByteBuddyAgent</td>
<td class="coverageStat">
  <span class="percent">
    34.5%
  </span>
  <span class="absValue">
    (10/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40.9%
  </span>
  <span class="absValue">
    (18/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (58/139)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ByteBuddyAgent$AgentProvider</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AgentProvider$ForByteBuddyAgent</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43.3%
  </span>
  <span class="absValue">
    (13/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41%
  </span>
  <span class="absValue">
    (25/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$Simple</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.2%
  </span>
  <span class="absValue">
    (6/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$Simple$WithExternalAttachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.2%
  </span>
  <span class="absValue">
    (13/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForEmulatedAttachment</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForJ9Vm</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForModularizedVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForStandardToolsJarVm</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (7/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForUserDefinedToolsJar</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator$InstallationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider$ForCurrentVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider$ForCurrentVm$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.8%
  </span>
  <span class="absValue">
    (7/13)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    61.8%
  </span>
  <span class="absValue">
    (42/68)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.1%
  </span>
  <span class="absValue">
    (37/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    49%
  </span>
  <span class="absValue">
    (150/306)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.agent;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLClassLoader;
&nbsp;import java.security.CodeSource;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.jar.Attributes;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarInputStream;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;import java.util.jar.Manifest;
&nbsp;import java.util.jar.Attributes.Name;
&nbsp;import net.bytebuddy.agent.VirtualMachine.Resolver;
&nbsp;import net.bytebuddy.agent.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.agent.utility.nullability.MaybeNull;
&nbsp;
&nbsp;public class ByteBuddyAgent {
&nbsp;    public static final String LATENT_RESOLVE = &quot;net.bytebuddy.agent.latent&quot;;
&nbsp;    private static final String AGENT_CLASS_PROPERTY = &quot;Agent-Class&quot;;
&nbsp;    private static final String CAN_REDEFINE_CLASSES_PROPERTY = &quot;Can-Redefine-Classes&quot;;
&nbsp;    private static final String CAN_RETRANSFORM_CLASSES_PROPERTY = &quot;Can-Retransform-Classes&quot;;
&nbsp;    private static final String CAN_SET_NATIVE_METHOD_PREFIX = &quot;Can-Set-Native-Method-Prefix&quot;;
&nbsp;    private static final String MANIFEST_VERSION_VALUE = &quot;1.0&quot;;
&nbsp;    private static final int BUFFER_SIZE = 8192;
&nbsp;    private static final int START_INDEX = 0;
&nbsp;    private static final int END_OF_FILE = -1;
&nbsp;    private static final int SUCCESSFUL_ATTACH = 0;
&nbsp;    @AlwaysNull
&nbsp;    private static final ClassLoader BOOTSTRAP_CLASS_LOADER = null;
&nbsp;    @AlwaysNull
&nbsp;    private static final String WITHOUT_ARGUMENT = null;
&nbsp;    private static final String ATTACHER_FILE_NAME = &quot;byteBuddyAttacher&quot;;
&nbsp;    private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;    private static final String JAR_FILE_EXTENSION = &quot;.jar&quot;;
&nbsp;    private static final String CLASS_PATH_ARGUMENT = &quot;-cp&quot;;
&nbsp;    private static final String JAVA_HOME = &quot;java.home&quot;;
&nbsp;    private static final String OS_NAME = &quot;os.name&quot;;
<b class="nc">&nbsp;    private static final String INSTRUMENTATION_METHOD = &quot;getInstrumentation&quot;;</b>
&nbsp;    private static final String FILE_PROTOCOL = &quot;file&quot;;
&nbsp;    @AlwaysNull
&nbsp;    private static final Instrumentation UNAVAILABLE = null;
&nbsp;    @AlwaysNull
&nbsp;    private static final File CANNOT_SELF_RESOLVE = null;
&nbsp;    private static final AttachmentTypeEvaluator ATTACHMENT_TYPE_EVALUATOR;
&nbsp;
&nbsp;    private ByteBuddyAgent() {
&nbsp;        throw new UnsupportedOperationException(&quot;This class is a utility class and not supposed to be instantiated&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;        try {
&nbsp;            return Class.forName(&quot;java.security.AccessController&quot;).getMethod(&quot;doPrivileged&quot;, PrivilegedAction.class).invoke((Object)null, action);
&nbsp;        } catch (ClassNotFoundException var2) {
&nbsp;            return action.run();
&nbsp;        } catch (InvocationTargetException var3) {
&nbsp;            InvocationTargetException exception = var3;
&nbsp;            throw new IllegalStateException(&quot;Failed to invoke access controller&quot;, exception.getTargetException());
&nbsp;        } catch (IllegalAccessException var4) {
&nbsp;            IllegalAccessException exception = var4;
&nbsp;            throw new IllegalStateException(&quot;Failed to access access controller&quot;, exception);
&nbsp;        } catch (NoSuchMethodException var5) {
&nbsp;            NoSuchMethodException exception = var5;
&nbsp;            throw new IllegalStateException(&quot;Failed to resolve well-known access controller method&quot;, exception);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Instrumentation getInstrumentation() {
&nbsp;        Instrumentation instrumentation = doGetInstrumentation();
&nbsp;        if (instrumentation == null) {
&nbsp;            throw new IllegalStateException(&quot;The Byte Buddy agent is not initialized or unavailable&quot;);
&nbsp;        } else {
&nbsp;            return instrumentation;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, String processId) {
&nbsp;        attach(agentJar, processId, WITHOUT_ARGUMENT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, String processId, @MaybeNull String argument) {
&nbsp;        attach(agentJar, processId, argument, ByteBuddyAgent.AttachmentProvider.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, String processId, AttachmentProvider attachmentProvider) {
&nbsp;        attach(agentJar, processId, WITHOUT_ARGUMENT, attachmentProvider);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, String processId, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
<b class="fc">&nbsp;        install(attachmentProvider, processId, argument, new AgentProvider.ForExistingAgent(agentJar), false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider) {
&nbsp;        attach(agentJar, processProvider, WITHOUT_ARGUMENT);
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, @MaybeNull String argument) {
&nbsp;        attach(agentJar, processProvider, argument, ByteBuddyAgent.AttachmentProvider.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, AttachmentProvider attachmentProvider) {
&nbsp;        attach(agentJar, processProvider, WITHOUT_ARGUMENT, attachmentProvider);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
&nbsp;        install(attachmentProvider, processProvider.resolve(), argument, new AgentProvider.ForExistingAgent(agentJar), false);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, String processId) {
&nbsp;        attachNative(agentLibrary, processId, WITHOUT_ARGUMENT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, String processId, @MaybeNull String argument) {
&nbsp;        attachNative(agentLibrary, processId, argument, ByteBuddyAgent.AttachmentProvider.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, String processId, AttachmentProvider attachmentProvider) {
&nbsp;        attachNative(agentLibrary, processId, WITHOUT_ARGUMENT, attachmentProvider);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, String processId, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
&nbsp;        install(attachmentProvider, processId, argument, new AgentProvider.ForExistingAgent(agentLibrary), true);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider) {
&nbsp;        attachNative(agentLibrary, processProvider, WITHOUT_ARGUMENT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, @MaybeNull String argument) {
&nbsp;        attachNative(agentLibrary, processProvider, argument, ByteBuddyAgent.AttachmentProvider.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, AttachmentProvider attachmentProvider) {
&nbsp;        attachNative(agentLibrary, processProvider, WITHOUT_ARGUMENT, attachmentProvider);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
&nbsp;        install(attachmentProvider, processProvider.resolve(), argument, new AgentProvider.ForExistingAgent(agentLibrary), true);
&nbsp;    }
&nbsp;
&nbsp;    public static Instrumentation install() {
<b class="fc">&nbsp;        return install(ByteBuddyAgent.AttachmentProvider.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Instrumentation install(AttachmentProvider attachmentProvider) {
&nbsp;        return install(attachmentProvider, ByteBuddyAgent.ProcessProvider.ForCurrentVm.INSTANCE);
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    public static Instrumentation install(ProcessProvider processProvider) {
&nbsp;        return install(ByteBuddyAgent.AttachmentProvider.DEFAULT, processProvider);
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static synchronized Instrumentation install(AttachmentProvider attachmentProvider, ProcessProvider processProvider) {</b>
&nbsp;        Instrumentation instrumentation = doGetInstrumentation();
&nbsp;        if (instrumentation != null) {
&nbsp;            return instrumentation;
&nbsp;        } else {
<b class="nc">&nbsp;            install(attachmentProvider, processProvider.resolve(), WITHOUT_ARGUMENT, ByteBuddyAgent.AgentProvider.ForByteBuddyAgent.INSTANCE, false);</b>
<b class="nc">&nbsp;            return getInstrumentation();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static void install(AttachmentProvider attachmentProvider, String processId, @MaybeNull String argument, AgentProvider agentProvider, boolean isNative) {
&nbsp;        AttachmentProvider.Accessor attachmentAccessor = attachmentProvider.attempt();
&nbsp;        if (!attachmentAccessor.isAvailable()) {
&nbsp;            throw new IllegalStateException(&quot;No compatible attachment provider is available&quot;);
&nbsp;        } else {
&nbsp;            try {
&nbsp;                if (attachmentAccessor.isExternalAttachmentRequired() &amp;&amp; ATTACHMENT_TYPE_EVALUATOR.requiresExternalAttachment(processId)) {
&nbsp;                    installExternal(attachmentAccessor.getExternalAttachment(), processId, agentProvider.resolve(), isNative, argument);
&nbsp;                } else {
<b class="fc">&nbsp;                    Attacher.install(attachmentAccessor.getVirtualMachineType(), processId, agentProvider.resolve().getAbsolutePath(), isNative, argument);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;            } catch (RuntimeException var7) {</b>
<b class="nc">&nbsp;                RuntimeException exception = var7;</b>
<b class="nc">&nbsp;                throw exception;</b>
<b class="nc">&nbsp;            } catch (Exception var8) {</b>
<b class="nc">&nbsp;                Exception exception = var8;</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Error during attachment using: &quot; + attachmentProvider, exception);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void installExternal(AttachmentProvider.Accessor.ExternalAttachment externalAttachment, String processId, File agent, boolean isNative, @MaybeNull String argument) throws Exception {
&nbsp;        File selfResolvedJar = trySelfResolve();
&nbsp;        File attachmentJar = null;
&nbsp;
&nbsp;        try {
&nbsp;            if (selfResolvedJar == null) {
&nbsp;                InputStream inputStream = Attacher.class.getResourceAsStream(&#39;/&#39; + Attacher.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
&nbsp;                if (inputStream == null) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot locate class file for Byte Buddy installation process&quot;);
&nbsp;                }
&nbsp;
&nbsp;                try {
&nbsp;                    attachmentJar = File.createTempFile(&quot;byteBuddyAttacher&quot;, &quot;.jar&quot;);
&nbsp;                    JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(attachmentJar));
&nbsp;
&nbsp;                    try {
<b class="fc">&nbsp;                        jarOutputStream.putNextEntry(new JarEntry(Attacher.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;));</b>
<b class="pc">&nbsp;                        byte[] buffer = new byte[8192];</b>
<b class="nc">&nbsp;</b>
&nbsp;                        while(true) {
<b class="fc">&nbsp;                            int index;</b>
&nbsp;                            if ((index = inputStream.read(buffer)) == -1) {
&nbsp;                                jarOutputStream.closeEntry();
&nbsp;                                break;
&nbsp;                            }
&nbsp;
&nbsp;                            jarOutputStream.write(buffer, 0, index);
&nbsp;                        }
&nbsp;                    } finally {
&nbsp;                        jarOutputStream.close();
&nbsp;                    }
&nbsp;                } finally {
&nbsp;                    inputStream.close();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            StringBuilder classPath = (new StringBuilder()).append((selfResolvedJar == null ? attachmentJar : selfResolvedJar).getCanonicalPath());
&nbsp;            Iterator var27 = externalAttachment.getClassPath().iterator();
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            while(var27.hasNext()) {</b>
&nbsp;                File jar = (File)var27.next();
&nbsp;                classPath.append(File.pathSeparatorChar).append(jar.getCanonicalPath());
&nbsp;            }
&nbsp;
&nbsp;            if ((new ProcessBuilder(new String[]{System.getProperty(&quot;java.home&quot;) + File.separatorChar + &quot;bin&quot; + File.separatorChar + (System.getProperty(&quot;os.name&quot;, &quot;&quot;).toLowerCase(Locale.US).contains(&quot;windows&quot;) ? &quot;java.exe&quot; : &quot;java&quot;), &quot;-Dnet.bytebuddy.agent.attacher.dump=&quot; + System.getProperty(&quot;net.bytebuddy.agent.attacher.dump&quot;, &quot;&quot;), &quot;-cp&quot;, classPath.toString(), Attacher.class.getName(), externalAttachment.getVirtualMachineType(), processId, agent.getAbsolutePath(), Boolean.toString(isNative), argument == null ? &quot;&quot; : &quot;=&quot; + argument})).start().waitFor() != 0) {
&nbsp;                throw new IllegalStateException(&quot;Could not self-attach to current VM using external process&quot;);
&nbsp;            }
&nbsp;        } finally {
&nbsp;            if (attachmentJar != null &amp;&amp; !attachmentJar.delete()) {
&nbsp;                attachmentJar.deleteOnExit();
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @MaybeNull</b>
<b class="nc">&nbsp;    @SuppressFBWarnings(</b>
&nbsp;        value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;        justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;    )
&nbsp;    private static File trySelfResolve() {
&nbsp;        try {
&nbsp;            if (Boolean.getBoolean(&quot;net.bytebuddy.agent.latent&quot;)) {
&nbsp;                return CANNOT_SELF_RESOLVE;
&nbsp;            } else {
&nbsp;                ProtectionDomain protectionDomain = Attacher.class.getProtectionDomain();
&nbsp;                if (protectionDomain == null) {
&nbsp;                    return CANNOT_SELF_RESOLVE;
&nbsp;                } else {
&nbsp;                    CodeSource codeSource = protectionDomain.getCodeSource();
&nbsp;                    if (codeSource == null) {
&nbsp;                        return CANNOT_SELF_RESOLVE;
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        URL location = codeSource.getLocation();</b>
&nbsp;                        if (!location.getProtocol().equals(&quot;file&quot;)) {
&nbsp;                            return CANNOT_SELF_RESOLVE;
&nbsp;                        } else {
&nbsp;                            try {
&nbsp;                                return new File(location.toURI());
&nbsp;                            } catch (URISyntaxException var4) {
&nbsp;                                return new File(location.getPath());
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (Exception var5) {
&nbsp;            return CANNOT_SELF_RESOLVE;
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @MaybeNull</b>
&nbsp;    @SuppressFBWarnings(
&nbsp;        value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;        justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;    )
&nbsp;    private static Instrumentation doGetInstrumentation() {
&nbsp;        try {
&nbsp;            Class&lt;?&gt; installer = Class.forName(Installer.class.getName(), true, ClassLoader.getSystemClassLoader());
&nbsp;
&nbsp;            try {
&nbsp;                Class&lt;?&gt; module = Class.forName(&quot;java.lang.Module&quot;);
&nbsp;                Method getModule = Class.class.getMethod(&quot;getModule&quot;);
&nbsp;                Object source = getModule.invoke(ByteBuddyAgent.class);
&nbsp;                Object target = getModule.invoke(installer);
&nbsp;                if (!(Boolean)module.getMethod(&quot;canRead&quot;, module).invoke(source, target)) {
&nbsp;                    module.getMethod(&quot;addReads&quot;, module).invoke(source, target);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException var5) {</b>
&nbsp;            }
&nbsp;
&nbsp;            return (Instrumentation)Class.forName(Installer.class.getName(), true, ClassLoader.getSystemClassLoader()).getMethod(&quot;getInstrumentation&quot;).invoke((Object)null);
&nbsp;        } catch (Exception var6) {
&nbsp;            return UNAVAILABLE;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static {
&nbsp;        ATTACHMENT_TYPE_EVALUATOR = (AttachmentTypeEvaluator)doPrivileged(ByteBuddyAgent.AttachmentTypeEvaluator.InstallationAction.INSTANCE);
&nbsp;    }
&nbsp;
&nbsp;    protected interface AttachmentTypeEvaluator {
&nbsp;        boolean requiresExternalAttachment(String var1);
&nbsp;
&nbsp;        public static class ForJava9CapableVm implements AttachmentTypeEvaluator {
<b class="nc">&nbsp;            private final Method current;</b>
<b class="nc">&nbsp;            private final Method pid;</b>
&nbsp;
&nbsp;            protected ForJava9CapableVm(Method current, Method pid) {
&nbsp;                this.current = current;
&nbsp;                this.pid = pid;
&nbsp;            }
&nbsp;
&nbsp;            public boolean requiresExternalAttachment(String processId) {
&nbsp;                try {
&nbsp;                    return this.pid.invoke(this.current.invoke((Object)null)).toString().equals(processId);
&nbsp;                } catch (IllegalAccessException var3) {
&nbsp;                    IllegalAccessException exception = var3;
&nbsp;                    throw new IllegalStateException(&quot;Cannot access Java 9 process API&quot;, exception);
&nbsp;                } catch (InvocationTargetException var4) {
&nbsp;                    InvocationTargetException exception = var4;
&nbsp;                    throw new IllegalStateException(&quot;Error when accessing Java 9 process API&quot;, exception.getTargetException());
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public static enum Disabled implements AttachmentTypeEvaluator {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Disabled() {
&nbsp;            }
&nbsp;
&nbsp;            public boolean requiresExternalAttachment(String processId) {
&nbsp;                return false;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum InstallationAction implements PrivilegedAction&lt;AttachmentTypeEvaluator&gt; {
&nbsp;            INSTANCE;
&nbsp;
<b class="nc">&nbsp;            private static final String JDK_ALLOW_SELF_ATTACH = &quot;jdk.attach.allowAttachSelf&quot;;</b>
<b class="nc">&nbsp;</b>
&nbsp;            private InstallationAction() {
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;            )
&nbsp;            public AttachmentTypeEvaluator run() {
&nbsp;                try {
&nbsp;                    return (AttachmentTypeEvaluator)(Boolean.getBoolean(&quot;jdk.attach.allowAttachSelf&quot;) ? ByteBuddyAgent.AttachmentTypeEvaluator.Disabled.INSTANCE : new ForJava9CapableVm(Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;current&quot;), Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;pid&quot;)));
&nbsp;                } catch (Exception var2) {
&nbsp;                    return ByteBuddyAgent.AttachmentTypeEvaluator.Disabled.INSTANCE;
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    protected interface AgentProvider {
&nbsp;        File resolve() throws IOException;
&nbsp;
&nbsp;        public static class ForExistingAgent implements AgentProvider {
&nbsp;            private final File agent;
&nbsp;
&nbsp;            protected ForExistingAgent(File agent) {
&nbsp;                this.agent = agent;
&nbsp;            }
&nbsp;
&nbsp;            public File resolve() {
&nbsp;                return this.agent;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForByteBuddyAgent implements AgentProvider {
<b class="nc">&nbsp;            INSTANCE;</b>
<b class="nc">&nbsp;</b>
&nbsp;            private static final String AGENT_FILE_NAME = &quot;byteBuddyAgent&quot;;
&nbsp;
&nbsp;            private ForByteBuddyAgent() {
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            private static File trySelfResolve() throws IOException {
&nbsp;                ProtectionDomain protectionDomain = Installer.class.getProtectionDomain();
&nbsp;                if (Boolean.getBoolean(&quot;net.bytebuddy.agent.latent&quot;)) {
&nbsp;                    return ByteBuddyAgent.CANNOT_SELF_RESOLVE;
&nbsp;                } else if (protectionDomain == null) {
&nbsp;                    return ByteBuddyAgent.CANNOT_SELF_RESOLVE;
&nbsp;                } else {
&nbsp;                    CodeSource codeSource = protectionDomain.getCodeSource();
&nbsp;                    if (codeSource == null) {
<b class="nc">&nbsp;                        return ByteBuddyAgent.CANNOT_SELF_RESOLVE;</b>
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        URL location = codeSource.getLocation();
&nbsp;                        if (!location.getProtocol().equals(&quot;file&quot;)) {
&nbsp;                            return ByteBuddyAgent.CANNOT_SELF_RESOLVE;
&nbsp;                        } else {
&nbsp;                            File agentJar;
&nbsp;                            try {
&nbsp;                                agentJar = new File(location.toURI());
&nbsp;                            } catch (URISyntaxException var11) {
&nbsp;                                agentJar = new File(location.getPath());
&nbsp;                            }
&nbsp;
&nbsp;                            if (agentJar.isFile() &amp;&amp; agentJar.canRead()) {
&nbsp;                                JarInputStream jarInputStream = new JarInputStream(new FileInputStream(agentJar));
&nbsp;
&nbsp;                                File var7;
&nbsp;                                try {
<b class="nc">&nbsp;                                    Manifest manifest = jarInputStream.getManifest();</b>
<b class="nc">&nbsp;                                    if (manifest == null) {</b>
&nbsp;                                        File var13 = ByteBuddyAgent.CANNOT_SELF_RESOLVE;
&nbsp;                                        return var13;
&nbsp;                                    }
&nbsp;
&nbsp;                                    Attributes attributes = manifest.getMainAttributes();
&nbsp;                                    if (attributes == null) {
&nbsp;                                        var7 = ByteBuddyAgent.CANNOT_SELF_RESOLVE;
&nbsp;                                        return var7;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (!Installer.class.getName().equals(attributes.getValue(&quot;Agent-Class&quot;)) || !Boolean.parseBoolean(attributes.getValue(&quot;Can-Redefine-Classes&quot;)) || !Boolean.parseBoolean(attributes.getValue(&quot;Can-Retransform-Classes&quot;)) || !Boolean.parseBoolean(attributes.getValue(&quot;Can-Set-Native-Method-Prefix&quot;))) {
&nbsp;                                        var7 = ByteBuddyAgent.CANNOT_SELF_RESOLVE;
&nbsp;                                        return var7;
&nbsp;                                    }
&nbsp;
<b class="nc">&nbsp;                                    var7 = agentJar;</b>
<b class="nc">&nbsp;                                } finally {</b>
&nbsp;                                    jarInputStream.close();
&nbsp;                                }
&nbsp;
&nbsp;                                return var7;
&nbsp;                            } else {
&nbsp;                                return ByteBuddyAgent.CANNOT_SELF_RESOLVE;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            private static File createJarFile() throws IOException {
&nbsp;                InputStream inputStream = Installer.class.getResourceAsStream(&#39;/&#39; + Installer.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
&nbsp;                if (inputStream == null) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot locate class file for Byte Buddy installer&quot;);
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    File var14;</b>
&nbsp;                    try {
&nbsp;                        File agentJar = File.createTempFile(&quot;byteBuddyAgent&quot;, &quot;.jar&quot;);
&nbsp;                        agentJar.deleteOnExit();
&nbsp;                        Manifest manifest = new Manifest();
&nbsp;                        manifest.getMainAttributes().put(Name.MANIFEST_VERSION, &quot;1.0&quot;);
&nbsp;                        manifest.getMainAttributes().put(new Attributes.Name(&quot;Agent-Class&quot;), Installer.class.getName());
&nbsp;                        manifest.getMainAttributes().put(new Attributes.Name(&quot;Can-Redefine-Classes&quot;), Boolean.TRUE.toString());
&nbsp;                        manifest.getMainAttributes().put(new Attributes.Name(&quot;Can-Retransform-Classes&quot;), Boolean.TRUE.toString());
&nbsp;                        manifest.getMainAttributes().put(new Attributes.Name(&quot;Can-Set-Native-Method-Prefix&quot;), Boolean.TRUE.toString());
&nbsp;                        JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(agentJar), manifest);
&nbsp;
&nbsp;                        try {
&nbsp;                            jarOutputStream.putNextEntry(new JarEntry(Installer.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;));
&nbsp;                            byte[] buffer = new byte[8192];
&nbsp;
<b class="nc">&nbsp;                            while(true) {</b>
<b class="nc">&nbsp;                                int index;</b>
&nbsp;                                if ((index = inputStream.read(buffer)) == -1) {
&nbsp;                                    jarOutputStream.closeEntry();
&nbsp;                                    break;
&nbsp;                                }
&nbsp;
&nbsp;                                jarOutputStream.write(buffer, 0, index);
&nbsp;                            }
&nbsp;                        } finally {
&nbsp;                            jarOutputStream.close();
&nbsp;                        }
&nbsp;
&nbsp;                        var14 = agentJar;
&nbsp;                    } finally {
&nbsp;                        inputStream.close();
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    return var14;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public File resolve() throws IOException {
&nbsp;                try {
&nbsp;                    File agentJar = trySelfResolve();
&nbsp;                    return agentJar == null ? createJarFile() : agentJar;
&nbsp;                } catch (Exception var2) {
&nbsp;                    return createJarFile();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface ProcessProvider {
&nbsp;        String resolve();
&nbsp;
&nbsp;        public static enum ForCurrentVm implements ProcessProvider {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private final ProcessProvider dispatcher = ByteBuddyAgent.ProcessProvider.ForCurrentVm.ForJava9CapableVm.make();
&nbsp;
&nbsp;            private ForCurrentVm() {
&nbsp;            }
&nbsp;
&nbsp;            public String resolve() {
&nbsp;                return this.dispatcher.resolve();
&nbsp;            }
&nbsp;
&nbsp;            protected static class ForJava9CapableVm implements ProcessProvider {
&nbsp;                private final Method current;
<b class="fc">&nbsp;                private final Method pid;</b>
&nbsp;
&nbsp;                protected ForJava9CapableVm(Method current, Method pid) {
&nbsp;                    this.current = current;
&nbsp;                    this.pid = pid;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                    justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;                )
&nbsp;                public static ProcessProvider make() {
&nbsp;                    try {
&nbsp;                        return new ForJava9CapableVm(Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;current&quot;), Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;pid&quot;));
&nbsp;                    } catch (Exception var1) {
&nbsp;                        return ByteBuddyAgent.ProcessProvider.ForCurrentVm.ForLegacyVm.INSTANCE;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public String resolve() {
&nbsp;                    try {
&nbsp;                        return this.pid.invoke(this.current.invoke((Object)null)).toString();
&nbsp;                    } catch (IllegalAccessException var2) {
<b class="fc">&nbsp;                        IllegalAccessException exception = var2;</b>
&nbsp;                        throw new IllegalStateException(&quot;Cannot access Java 9 process API&quot;, exception);
&nbsp;                    } catch (InvocationTargetException var3) {
&nbsp;                        InvocationTargetException exception = var3;
&nbsp;                        throw new IllegalStateException(&quot;Error when accessing Java 9 process API&quot;, exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static enum ForLegacyVm implements ProcessProvider {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private ForLegacyVm() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                    justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;                )
&nbsp;                public String resolve() {
&nbsp;                    String runtimeName;
&nbsp;                    try {
&nbsp;                        Method method = Class.forName(&quot;java.lang.management.ManagementFactory&quot;).getMethod(&quot;getRuntimeMXBean&quot;);
&nbsp;                        runtimeName = (String)method.getReturnType().getMethod(&quot;getName&quot;).invoke(method.invoke((Object)null));
&nbsp;                    } catch (Exception var3) {
&nbsp;                        Exception exception = var3;
&nbsp;                        throw new IllegalStateException(&quot;Failed to access VM name via management factory&quot;, exception);
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    int processIdIndex = runtimeName.indexOf(64);
&nbsp;                    if (processIdIndex == -1) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot extract process id from runtime management bean&quot;);
&nbsp;                    } else {
&nbsp;                        return runtimeName.substring(0, processIdIndex);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(
&nbsp;        value = {&quot;IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION&quot;},
&nbsp;        justification = &quot;Safe initialization is implied&quot;
&nbsp;    )
<b class="fc">&nbsp;    public interface AttachmentProvider {</b>
<b class="fc">&nbsp;        AttachmentProvider DEFAULT = new Compound(new AttachmentProvider[]{ByteBuddyAgent.AttachmentProvider.ForModularizedVm.INSTANCE, ByteBuddyAgent.AttachmentProvider.ForJ9Vm.INSTANCE, ByteBuddyAgent.AttachmentProvider.ForStandardToolsJarVm.JVM_ROOT, ByteBuddyAgent.AttachmentProvider.ForStandardToolsJarVm.JDK_ROOT, ByteBuddyAgent.AttachmentProvider.ForStandardToolsJarVm.MACINTOSH, ByteBuddyAgent.AttachmentProvider.ForUserDefinedToolsJar.INSTANCE, ByteBuddyAgent.AttachmentProvider.ForEmulatedAttachment.INSTANCE});</b>
<b class="fc">&nbsp;</b>
&nbsp;        Accessor attempt();
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public static class Compound implements AttachmentProvider {</b>
&nbsp;            private final List&lt;AttachmentProvider&gt; attachmentProviders;
&nbsp;
&nbsp;            public Compound(AttachmentProvider... attachmentProvider) {
&nbsp;                this(Arrays.asList(attachmentProvider));
&nbsp;            }
&nbsp;
&nbsp;            public Compound(List&lt;? extends AttachmentProvider&gt; attachmentProviders) {
&nbsp;                this.attachmentProviders = new ArrayList();
&nbsp;                Iterator var2 = attachmentProviders.iterator();
&nbsp;
&nbsp;                while(var2.hasNext()) {
&nbsp;                    AttachmentProvider attachmentProvider = (AttachmentProvider)var2.next();
<b class="fc">&nbsp;                    if (attachmentProvider instanceof Compound) {</b>
<b class="pc">&nbsp;                        this.attachmentProviders.addAll(((Compound)attachmentProvider).attachmentProviders);</b>
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        this.attachmentProviders.add(attachmentProvider);
&nbsp;                    }
<b class="pc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            public Accessor attempt() {
<b class="nc">&nbsp;                Iterator var1 = this.attachmentProviders.iterator();</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                Accessor accessor;</b>
<b class="nc">&nbsp;                do {</b>
&nbsp;                    if (!var1.hasNext()) {
<b class="fc">&nbsp;                        return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    AttachmentProvider attachmentProvider = (AttachmentProvider)var1.next();
&nbsp;                    accessor = attachmentProvider.attempt();
&nbsp;                } while(!accessor.isAvailable());
&nbsp;
&nbsp;                return accessor;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForEmulatedAttachment implements AttachmentProvider {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForEmulatedAttachment() {
&nbsp;            }
&nbsp;
&nbsp;            public Accessor attempt() {
<b class="fc">&nbsp;                try {</b>
&nbsp;                    return new Accessor.Simple.WithDirectAttachment((Class)ByteBuddyAgent.doPrivileged(Resolver.INSTANCE));
<b class="pc">&nbsp;                } catch (Throwable var2) {</b>
<b class="nc">&nbsp;                    return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public static enum ForUserDefinedToolsJar implements AttachmentProvider {</b>
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
<b class="nc">&nbsp;            public static final String PROPERTY = &quot;net.bytebuddy.agent.toolsjar&quot;;</b>
<b class="nc">&nbsp;</b>
&nbsp;            private ForUserDefinedToolsJar() {
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            @SuppressFBWarnings(
<b class="nc">&nbsp;                value = {&quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;},</b>
&nbsp;                justification = &quot;Assuring privilege is explicit user responsibility.&quot;
<b class="nc">&nbsp;            )</b>
<b class="nc">&nbsp;            public Accessor attempt() {</b>
&nbsp;                String location = System.getProperty(&quot;net.bytebuddy.agent.toolsjar&quot;);
<b class="nc">&nbsp;                if (location == null) {</b>
<b class="nc">&nbsp;                    return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;</b>
&nbsp;                } else {
<b class="pc">&nbsp;                    File toolsJar = new File(location);</b>
&nbsp;
<b class="fc">&nbsp;                    try {</b>
<b class="pc">&nbsp;                        return ByteBuddyAgent.AttachmentProvider.Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, ByteBuddyAgent.BOOTSTRAP_CLASS_LOADER), toolsJar);</b>
<b class="nc">&nbsp;                    } catch (MalformedURLException var4) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Could not represent &quot; + toolsJar + &quot; as URL&quot;);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="pc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        public static enum ForStandardToolsJarVm implements AttachmentProvider {</b>
<b class="fc">&nbsp;            JVM_ROOT(&quot;../lib/tools.jar&quot;),</b>
<b class="fc">&nbsp;            JDK_ROOT(&quot;lib/tools.jar&quot;),</b>
&nbsp;            MACINTOSH(&quot;../Classes/classes.jar&quot;);
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;            private static final String JAVA_HOME_PROPERTY = &quot;java.home&quot;;</b>
<b class="pc">&nbsp;            private final String toolsJarPath;</b>
<b class="nc">&nbsp;</b>
&nbsp;            private ForStandardToolsJarVm(String toolsJarPath) {
&nbsp;                this.toolsJarPath = toolsJarPath;
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @SuppressFBWarnings(</b>
&nbsp;                value = {&quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;},
&nbsp;                justification = &quot;Assuring privilege is explicit user responsibility.&quot;
<b class="nc">&nbsp;            )</b>
<b class="fc">&nbsp;            public Accessor attempt() {</b>
&nbsp;                File toolsJar = new File(System.getProperty(&quot;java.home&quot;), this.toolsJarPath);
&nbsp;
&nbsp;                try {
&nbsp;                    return (Accessor)(toolsJar.isFile() &amp;&amp; toolsJar.canRead() ? ByteBuddyAgent.AttachmentProvider.Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, ByteBuddyAgent.BOOTSTRAP_CLASS_LOADER), toolsJar) : ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE);
&nbsp;                } catch (MalformedURLException var3) {
&nbsp;                    throw new IllegalStateException(&quot;Could not represent &quot; + toolsJar + &quot; as URL&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        public static enum ForJ9Vm implements AttachmentProvider {</b>
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
<b class="fc">&nbsp;            private ForJ9Vm() {</b>
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public Accessor attempt() {
<b class="fc">&nbsp;                return ByteBuddyAgent.AttachmentProvider.Accessor.Simple.ofJ9();</b>
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        public static enum ForModularizedVm implements AttachmentProvider {</b>
<b class="pc">&nbsp;            INSTANCE;</b>
<b class="nc">&nbsp;</b>
&nbsp;            private ForModularizedVm() {
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;            public Accessor attempt() {</b>
<b class="nc">&nbsp;                return ByteBuddyAgent.AttachmentProvider.Accessor.Simple.of(ClassLoader.getSystemClassLoader());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public interface Accessor {
&nbsp;            String VIRTUAL_MACHINE_TYPE_NAME = &quot;com.sun.tools.attach.VirtualMachine&quot;;
&nbsp;            String VIRTUAL_MACHINE_TYPE_NAME_J9 = &quot;com.ibm.tools.attach.VirtualMachine&quot;;
&nbsp;
&nbsp;            boolean isAvailable();
&nbsp;
&nbsp;            boolean isExternalAttachmentRequired();
&nbsp;
&nbsp;            Class&lt;?&gt; getVirtualMachineType();
&nbsp;
&nbsp;            ExternalAttachment getExternalAttachment();
&nbsp;
&nbsp;            public abstract static class Simple implements Accessor {
<b class="fc">&nbsp;                protected final Class&lt;?&gt; virtualMachineType;</b>
&nbsp;
<b class="fc">&nbsp;                protected Simple(Class&lt;?&gt; virtualMachineType) {</b>
<b class="fc">&nbsp;                    this.virtualMachineType = virtualMachineType;</b>
<b class="fc">&nbsp;                }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                public static Accessor of(@MaybeNull ClassLoader classLoader, File... classPath) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        return new WithExternalAttachment(Class.forName(&quot;com.sun.tools.attach.VirtualMachine&quot;, false, classLoader), Arrays.asList(classPath));</b>
&nbsp;                    } catch (ClassNotFoundException var3) {
<b class="fc">&nbsp;                        return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public static Accessor ofJ9() {</b>
<b class="fc">&nbsp;                    try {</b>
&nbsp;                        return new WithExternalAttachment(ClassLoader.getSystemClassLoader().loadClass(&quot;com.ibm.tools.attach.VirtualMachine&quot;), Collections.emptyList());
&nbsp;                    } catch (ClassNotFoundException var1) {
&nbsp;                        return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; getVirtualMachineType() {
&nbsp;                    return this.virtualMachineType;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected static class WithDirectAttachment extends Simple {
&nbsp;                    public WithDirectAttachment(Class&lt;?&gt; virtualMachineType) {
&nbsp;                        super(virtualMachineType);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isExternalAttachmentRequired() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    public ExternalAttachment getExternalAttachment() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot apply external attachment&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class WithExternalAttachment extends Simple {
&nbsp;                    private final List&lt;File&gt; classPath;
&nbsp;
&nbsp;                    public WithExternalAttachment(Class&lt;?&gt; virtualMachineType, List&lt;File&gt; classPath) {
&nbsp;                        super(virtualMachineType);
&nbsp;                        this.classPath = classPath;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isExternalAttachmentRequired() {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    public ExternalAttachment getExternalAttachment() {
&nbsp;                        return new ExternalAttachment(this.virtualMachineType.getName(), this.classPath);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ExternalAttachment {
&nbsp;                private final String virtualMachineType;
&nbsp;                private final List&lt;File&gt; classPath;
&nbsp;
&nbsp;                public ExternalAttachment(String virtualMachineType, List&lt;File&gt; classPath) {
&nbsp;                    this.virtualMachineType = virtualMachineType;
&nbsp;                    this.classPath = classPath;
&nbsp;                }
&nbsp;
&nbsp;                public String getVirtualMachineType() {
&nbsp;                    return this.virtualMachineType;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;File&gt; getClassPath() {
&nbsp;                    return this.classPath;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Unavailable implements Accessor {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Unavailable() {
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isExternalAttachmentRequired() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; getVirtualMachineType() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public ExternalAttachment getExternalAttachment() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-05-14 20:57</div>
</div>
</body>
</html>
