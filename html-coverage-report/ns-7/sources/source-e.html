


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Graphics</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.badlogic.gdx</a>
</div>

<h1>Coverage Summary for Class: Graphics (com.badlogic.gdx)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
</tr>
<tr>
  <td class="name">Graphics</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright 2011 See AUTHORS file.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *   http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; ******************************************************************************/
&nbsp;
&nbsp;package com.badlogic.gdx;
&nbsp;
&nbsp;import com.badlogic.gdx.graphics.Cursor;
&nbsp;import com.badlogic.gdx.graphics.Cursor.SystemCursor;
&nbsp;import com.badlogic.gdx.graphics.GL20;
&nbsp;import com.badlogic.gdx.graphics.GL30;
&nbsp;import com.badlogic.gdx.graphics.GL31;
&nbsp;import com.badlogic.gdx.graphics.GL32;
&nbsp;import com.badlogic.gdx.graphics.Mesh;
&nbsp;import com.badlogic.gdx.graphics.Pixmap;
&nbsp;import com.badlogic.gdx.graphics.g2d.Batch;
&nbsp;import com.badlogic.gdx.graphics.g2d.BitmapFont;
&nbsp;import com.badlogic.gdx.graphics.glutils.FrameBuffer;
&nbsp;import com.badlogic.gdx.graphics.glutils.GLVersion;
&nbsp;import com.badlogic.gdx.graphics.glutils.IndexBufferObject;
&nbsp;import com.badlogic.gdx.graphics.glutils.ShaderProgram;
&nbsp;import com.badlogic.gdx.graphics.glutils.VertexArray;
&nbsp;import com.badlogic.gdx.graphics.glutils.VertexBufferObject;
&nbsp;
&nbsp;/** This interface encapsulates communication with the graphics processor. Depending on the available hardware and the current
&nbsp; * {@link Application} configuration, access to {@link GL20} and {@link GL30} are provided here.
&nbsp; * &lt;p&gt;
&nbsp; * If supported by the backend, this interface lets you query the available display modes (graphics resolution and color depth)
&nbsp; * and change it.
&nbsp; * &lt;p&gt;
&nbsp; * This interface can be used to switch between continuous and non-continuous rendering (see
&nbsp; * {@link #setContinuousRendering(boolean)}), and to explicitly {@link #requestRendering()}.
&nbsp; * &lt;p&gt;
&nbsp; * There are many more utility classes that are not directly generated by the {@link Graphics} interfaces. See {@link VertexArray}
&nbsp; * , {@link VertexBufferObject}, {@link IndexBufferObject}, {@link Mesh}, {@link ShaderProgram} and {@link FrameBuffer},
&nbsp; * {@link BitmapFont}, {@link Batch} and so on. All these classes are managed, meaning they don&#39;t need to be reloaded on a context
&nbsp; * loss. Explore the com.badlogic.gdx.graphics package for more classes that might come in handy.
&nbsp; * @author mzechner */
&nbsp;public interface Graphics {
&nbsp;	/** Enumeration describing different types of {@link Graphics} implementations.
&nbsp;	 *
&nbsp;	 * @author mzechner */
&nbsp;	enum GraphicsType {
&nbsp;		AndroidGL, LWJGL, WebGL, iOSGL, JGLFW, Mock, LWJGL3
&nbsp;	}
&nbsp;
&nbsp;	/** Describe a fullscreen display mode
&nbsp;	 *
&nbsp;	 * @author mzechner */
&nbsp;	class DisplayMode {
&nbsp;		/** the width in physical pixels **/
&nbsp;		public final int width;
&nbsp;		/** the height in physical pixels **/
&nbsp;		public final int height;
&nbsp;		/** the refresh rate in Hertz **/
&nbsp;		public final int refreshRate;
&nbsp;		/** the number of bits per pixel, may exclude alpha **/
&nbsp;		public final int bitsPerPixel;
&nbsp;
&nbsp;		protected DisplayMode (int width, int height, int refreshRate, int bitsPerPixel) {
&nbsp;			this.width = width;
&nbsp;			this.height = height;
&nbsp;			this.refreshRate = refreshRate;
&nbsp;			this.bitsPerPixel = bitsPerPixel;
&nbsp;		}
&nbsp;
&nbsp;		public String toString () {
&nbsp;			return width + &quot;x&quot; + height + &quot;, bpp: &quot; + bitsPerPixel + &quot;, hz: &quot; + refreshRate;
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/** Describes a monitor
&nbsp;	 *
&nbsp;	 * @author badlogic */
&nbsp;	class Monitor {
&nbsp;		public final int virtualX;
&nbsp;		public final int virtualY;
&nbsp;		public final String name;
&nbsp;
&nbsp;		protected Monitor (int virtualX, int virtualY, String name) {
&nbsp;			this.virtualX = virtualX;
&nbsp;			this.virtualY = virtualY;
&nbsp;			this.name = name;
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/** Class describing the bits per pixel, depth buffer precision, stencil precision and number of MSAA samples. */
&nbsp;	class BufferFormat {
&nbsp;		/* number of bits per color channel */
&nbsp;		public final int r, g, b, a;
&nbsp;		/* number of bits for depth and stencil buffer */
&nbsp;		public final int depth, stencil;
&nbsp;		/** number of samples for multi-sample anti-aliasing (MSAA) **/
&nbsp;		public final int samples;
&nbsp;		/** whether coverage sampling anti-aliasing is used. in that case you have to clear the coverage buffer as well! */
&nbsp;		public final boolean coverageSampling;
&nbsp;
&nbsp;		public BufferFormat (int r, int g, int b, int a, int depth, int stencil, int samples, boolean coverageSampling) {
&nbsp;			this.r = r;
&nbsp;			this.g = g;
&nbsp;			this.b = b;
&nbsp;			this.a = a;
&nbsp;			this.depth = depth;
&nbsp;			this.stencil = stencil;
&nbsp;			this.samples = samples;
&nbsp;			this.coverageSampling = coverageSampling;
&nbsp;		}
&nbsp;
&nbsp;		public String toString () {
&nbsp;			return &quot;r: &quot; + r + &quot;, g: &quot; + g + &quot;, b: &quot; + b + &quot;, a: &quot; + a + &quot;, depth: &quot; + depth + &quot;, stencil: &quot; + stencil
&nbsp;				+ &quot;, num samples: &quot; + samples + &quot;, coverage sampling: &quot; + coverageSampling;
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/** Returns whether OpenGL ES 3.0 is available. If it is you can get an instance of {@link GL30} via {@link #getGL30()} to
&nbsp;	 * access OpenGL ES 3.0 functionality. Note that this functionality will only be available if you instructed the
&nbsp;	 * {@link Application} instance to use OpenGL ES 3.0!
&nbsp;	 *
&nbsp;	 * @return whether OpenGL ES 3.0 is available */
&nbsp;	boolean isGL30Available ();
&nbsp;
&nbsp;	/** Returns whether OpenGL ES 3.1 is available. If it is you can get an instance of {@link GL31} via {@link #getGL31()} to
&nbsp;	 * access OpenGL ES 3.1 functionality. Note that this functionality will only be available if you instructed the
&nbsp;	 * {@link Application} instance to use OpenGL ES 3.1!
&nbsp;	 *
&nbsp;	 * @return whether OpenGL ES 3.1 is available */
&nbsp;	boolean isGL31Available ();
&nbsp;
&nbsp;	/** Returns whether OpenGL ES 3.2 is available. If it is you can get an instance of {@link GL32} via {@link #getGL32()} to
&nbsp;	 * access OpenGL ES 3.2 functionality. Note that this functionality will only be available if you instructed the
&nbsp;	 * {@link Application} instance to use OpenGL ES 3.2!
&nbsp;	 *
&nbsp;	 * @return whether OpenGL ES 3.2 is available */
&nbsp;	boolean isGL32Available ();
&nbsp;
&nbsp;	/** @return the {@link GL20} instance */
&nbsp;	GL20 getGL20 ();
&nbsp;
&nbsp;	/** @return the {@link GL30} instance or null if not supported */
&nbsp;	GL30 getGL30 ();
&nbsp;
&nbsp;	/** @return the {@link GL31} instance or null if not supported */
&nbsp;	GL31 getGL31 ();
&nbsp;
&nbsp;	/** @return the {@link GL32} instance or null if not supported */
&nbsp;	GL32 getGL32 ();
&nbsp;
&nbsp;	/** Set the GL20 instance **/
&nbsp;	void setGL20 (GL20 gl20);
&nbsp;
&nbsp;	/** Set the GL30 instance **/
&nbsp;	void setGL30 (GL30 gl30);
&nbsp;
&nbsp;	/** Set the GL31 instance **/
&nbsp;	void setGL31 (GL31 gl31);
&nbsp;
&nbsp;	/** Set the GL32 instance **/
&nbsp;	void setGL32 (GL32 gl32);
&nbsp;
&nbsp;	/** @return the width of the client area in logical pixels. */
&nbsp;	int getWidth ();
&nbsp;
&nbsp;	/** @return the height of the client area in logical pixels */
&nbsp;	int getHeight ();
&nbsp;
&nbsp;	/** @return the width of the framebuffer in physical pixels */
&nbsp;	int getBackBufferWidth ();
&nbsp;
&nbsp;	/** @return the height of the framebuffer in physical pixels */
&nbsp;	int getBackBufferHeight ();
&nbsp;
&nbsp;	/** @return amount of pixels per logical pixel (point) */
&nbsp;	float getBackBufferScale ();
&nbsp;
&nbsp;	/** @return the inset from the left which avoids display cutouts in logical pixels */
&nbsp;	int getSafeInsetLeft ();
&nbsp;
&nbsp;	/** @return the inset from the top which avoids display cutouts in logical pixels */
&nbsp;	int getSafeInsetTop ();
&nbsp;
&nbsp;	/** @return the inset from the bottom which avoids display cutouts or floating gesture bars, in logical pixels */
&nbsp;	int getSafeInsetBottom ();
&nbsp;
&nbsp;	/** @return the inset from the right which avoids display cutouts in logical pixels */
&nbsp;	int getSafeInsetRight ();
&nbsp;
&nbsp;	/** Returns the id of the current frame. The general contract of this method is that the id is incremented only when the
&nbsp;	 * application is in the running state right before calling the {@link ApplicationListener#render()} method. Also, the id of
&nbsp;	 * the first frame is 0; the id of subsequent frames is guaranteed to take increasing values for 2&lt;sup&gt;63&lt;/sup&gt;-1 rendering
&nbsp;	 * cycles.
&nbsp;	 * @return the id of the current frame */
&nbsp;	long getFrameId ();
&nbsp;
&nbsp;	/** @return the time span between the current frame and the last frame in seconds. */
&nbsp;	float getDeltaTime ();
&nbsp;
&nbsp;	/** @return the time span between the current frame and the last frame in seconds, without smoothing
&nbsp;	 * @deprecated use {@link #getDeltaTime()} instead. */
&nbsp;	@Deprecated
&nbsp;	float getRawDeltaTime ();
&nbsp;
&nbsp;	/** @return the average number of frames per second */
&nbsp;	int getFramesPerSecond ();
&nbsp;
&nbsp;	/** @return the {@link GraphicsType} of this Graphics instance */
&nbsp;	GraphicsType getType ();
&nbsp;
&nbsp;	/** @return the {@link GLVersion} of this Graphics instance */
&nbsp;	GLVersion getGLVersion ();
&nbsp;
&nbsp;	/** @return the pixels per inch on the x-axis */
&nbsp;	float getPpiX ();
&nbsp;
&nbsp;	/** @return the pixels per inch on the y-axis */
&nbsp;	float getPpiY ();
&nbsp;
&nbsp;	/** @return the pixels per centimeter on the x-axis */
&nbsp;	float getPpcX ();
&nbsp;
&nbsp;	/** @return the pixels per centimeter on the y-axis. */
&nbsp;	float getPpcY ();
&nbsp;
&nbsp;	/** This is a scaling factor for the Density Independent Pixel unit, following the same conventions as
&nbsp;	 * android.util.DisplayMetrics#density, where one DIP is one pixel on an approximately 160 dpi screen. Thus on a 160dpi screen
&nbsp;	 * this density value will be 1; on a 120 dpi screen it would be .75; etc.
&nbsp;	 *
&nbsp;	 * If the density could not be determined, this returns a default value of 1.
&nbsp;	 *
&nbsp;	 * Depending on the underlying platform implementation this might be a relatively expensive operation. Therefore it should not
&nbsp;	 * be called continously on each frame.
&nbsp;	 *
&nbsp;	 * @return the Density Independent Pixel factor of the display. */
&nbsp;	float getDensity ();
&nbsp;
&nbsp;	/** Whether the given backend supports a display mode change via calling {@link Graphics#setFullscreenMode(DisplayMode)}
&nbsp;	 *
&nbsp;	 * @return whether display mode changes are supported or not. */
&nbsp;	boolean supportsDisplayModeChange ();
&nbsp;
&nbsp;	/** @return the primary monitor **/
&nbsp;	Monitor getPrimaryMonitor ();
&nbsp;
&nbsp;	/** @return the monitor the application&#39;s window is located on */
&nbsp;	Monitor getMonitor ();
&nbsp;
&nbsp;	/** @return the currently connected {@link Monitor}s */
&nbsp;	Monitor[] getMonitors ();
&nbsp;
&nbsp;	/** @return the supported fullscreen {@link DisplayMode}(s) of the monitor the window is on */
&nbsp;	DisplayMode[] getDisplayModes ();
&nbsp;
&nbsp;	/** @return the supported fullscreen {@link DisplayMode}s of the given {@link Monitor} */
&nbsp;	DisplayMode[] getDisplayModes (Monitor monitor);
&nbsp;
&nbsp;	/** @return the current {@link DisplayMode} of the monitor the window is on. */
&nbsp;	DisplayMode getDisplayMode ();
&nbsp;
&nbsp;	/** @return the current {@link DisplayMode} of the given {@link Monitor} */
&nbsp;	DisplayMode getDisplayMode (Monitor monitor);
&nbsp;
&nbsp;	/** Sets the window to full-screen mode.
&nbsp;	 *
&nbsp;	 * @param displayMode the display mode.
&nbsp;	 * @return whether the operation succeeded. */
&nbsp;	boolean setFullscreenMode (DisplayMode displayMode);
&nbsp;
&nbsp;	/** Sets the window to windowed mode.
&nbsp;	 *
&nbsp;	 * @param width the width in pixels
&nbsp;	 * @param height the height in pixels
&nbsp;	 * @return whether the operation succeeded */
&nbsp;	boolean setWindowedMode (int width, int height);
&nbsp;
&nbsp;	/** Sets the title of the window. Ignored on Android.
&nbsp;	 *
&nbsp;	 * @param title the title. */
&nbsp;	void setTitle (String title);
&nbsp;
&nbsp;	/** Sets the window decoration as enabled or disabled. On Android, this will enable/disable the menu bar.
&nbsp;	 *
&nbsp;	 * Note that immediate behavior of this method may vary depending on the implementation. It may be necessary for the window to
&nbsp;	 * be recreated in order for the changes to take effect. Consult the documentation for the backend in use for more information.
&nbsp;	 *
&nbsp;	 * Supported on all GDX desktop backends and on Android (to disable the menu bar).
&nbsp;	 *
&nbsp;	 * @param undecorated true if the window border or status bar should be hidden. false otherwise. */
&nbsp;	void setUndecorated (boolean undecorated);
&nbsp;
&nbsp;	/** Sets whether or not the window should be resizable. Ignored on Android.
&nbsp;	 *
&nbsp;	 * Note that immediate behavior of this method may vary depending on the implementation. It may be necessary for the window to
&nbsp;	 * be recreated in order for the changes to take effect. Consult the documentation for the backend in use for more information.
&nbsp;	 *
&nbsp;	 * Supported on all GDX desktop backends.
&nbsp;	 *
&nbsp;	 * @param resizable */
&nbsp;	void setResizable (boolean resizable);
&nbsp;
&nbsp;	/** Enable/Disable vsynching. This is a best-effort attempt which might not work on all platforms.
&nbsp;	 *
&nbsp;	 * @param vsync vsync enabled or not. */
&nbsp;	void setVSync (boolean vsync);
&nbsp;
&nbsp;	/** Sets the target framerate for the application when using continuous rendering. Might not work on all platforms. Is not
&nbsp;	 * generally advised to be used on mobile platforms.
&nbsp;	 *
&nbsp;	 * @param fps the targeted fps; default differs by platform */
&nbsp;	public void setForegroundFPS (int fps);
&nbsp;
&nbsp;	/** @return the format of the color, depth and stencil buffer in a {@link BufferFormat} instance */
&nbsp;	BufferFormat getBufferFormat ();
&nbsp;
&nbsp;	/** @param extension the extension name
&nbsp;	 * @return whether the extension is supported */
&nbsp;	boolean supportsExtension (String extension);
&nbsp;
&nbsp;	/** Sets whether to render continuously. In case rendering is performed non-continuously, the following events will trigger a
&nbsp;	 * redraw:
&nbsp;	 *
&nbsp;	 * &lt;ul&gt;
&nbsp;	 * &lt;li&gt;A call to {@link #requestRendering()}&lt;/li&gt;
&nbsp;	 * &lt;li&gt;Input events from the touch screen/mouse or keyboard&lt;/li&gt;
&nbsp;	 * &lt;li&gt;A {@link Runnable} is posted to the rendering thread via {@link Application#postRunnable(Runnable)}. In the case of a
&nbsp;	 * multi-window app, all windows will request rendering if a runnable is posted to the application. To avoid this, post a
&nbsp;	 * runnable to the window instead.&lt;/li&gt;
&nbsp;	 * &lt;/ul&gt;
&nbsp;	 *
&nbsp;	 * Life-cycle events will also be reported as usual, see {@link ApplicationListener}. This method can be called from any
&nbsp;	 * thread.
&nbsp;	 *
&nbsp;	 * @param isContinuous whether the rendering should be continuous or not. */
&nbsp;	void setContinuousRendering (boolean isContinuous);
&nbsp;
&nbsp;	/** @return whether rendering is continuous. */
&nbsp;	boolean isContinuousRendering ();
&nbsp;
&nbsp;	/** Requests a new frame to be rendered if the rendering mode is non-continuous. This method can be called from any thread. */
&nbsp;	void requestRendering ();
&nbsp;
&nbsp;	/** Whether the app is fullscreen or not */
&nbsp;	boolean isFullscreen ();
&nbsp;
&nbsp;	/** Create a new cursor represented by the {@link com.badlogic.gdx.graphics.Pixmap}. The Pixmap must be in RGBA8888 format,
&nbsp;	 * width &amp; height must be powers-of-two greater than zero (not necessarily equal) and of a certain minimum size (32x32 is a
&nbsp;	 * safe bet), and alpha transparency must be single-bit (i.e., 0x00 or 0xFF only). This function returns a Cursor object that
&nbsp;	 * can be set as the system cursor by calling {@link #setCursor(Cursor)} .
&nbsp;	 *
&nbsp;	 * @param pixmap the mouse cursor image as a {@link com.badlogic.gdx.graphics.Pixmap}
&nbsp;	 * @param xHotspot the x location of the hotspot pixel within the cursor image (origin top-left corner)
&nbsp;	 * @param yHotspot the y location of the hotspot pixel within the cursor image (origin top-left corner)
&nbsp;	 * @return a cursor object that can be used by calling {@link #setCursor(Cursor)} or null if not supported */
&nbsp;	Cursor newCursor (Pixmap pixmap, int xHotspot, int yHotspot);
&nbsp;
&nbsp;	/** Only viable on the lwjgl-backend and on the gwt-backend. Browsers that support cursor:url() and support the png format (the
&nbsp;	 * pixmap is converted to a data-url of type image/png) should also support custom cursors. Will set the mouse cursor image to
&nbsp;	 * the image represented by the {@link com.badlogic.gdx.graphics.Cursor}. It is recommended to call this function in the main
&nbsp;	 * render thread, and maximum one time per frame.
&nbsp;	 *
&nbsp;	 * @param cursor the mouse cursor as a {@link com.badlogic.gdx.graphics.Cursor} */
&nbsp;	void setCursor (Cursor cursor);
&nbsp;
&nbsp;	/** Sets one of the predefined {@link SystemCursor}s */
&nbsp;	void setSystemCursor (SystemCursor systemCursor);
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-05-14 20:57</div>
</div>
</body>
</html>
