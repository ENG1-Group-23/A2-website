


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MethodCall</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: MethodCall (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodCall</td>
<td class="coverageStat">
  <span class="percent">
    19.5%
  </span>
  <span class="absValue">
    (8/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.7%
  </span>
  <span class="absValue">
    (5/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (24/96)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97%
  </span>
  <span class="absValue">
    (32/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ArgumentProvider</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForInstance$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameter$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForNullConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForContextualInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForContextualInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForVirtualInvocation$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator$ForExplicitMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForField$Location</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodCall$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodCall$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.6%
  </span>
  <span class="absValue">
    (12/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodParameter$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForSelfOrStaticInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForSelfOrStaticInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForSelfOrStaticInvocation$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (5/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.8%
  </span>
  <span class="absValue">
    (11/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$Resolved</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Simple$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Simple$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Simple$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$WithoutSpecifiedTarget</td>
<td class="coverageStat">
  <span class="percent">
    23.1%
  </span>
  <span class="absValue">
    (3/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31.6%
  </span>
  <span class="absValue">
    (6/19)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    55.2%
  </span>
  <span class="absValue">
    (64/116)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    34.7%
  </span>
  <span class="absValue">
    (34/98)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.7%
  </span>
  <span class="absValue">
    (168/291)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition.Sort;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.Removal;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation.Trivial;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.DoubleConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.FloatConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.JavaConstantValue;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.LongConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.NullConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.TextConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.utility.JavaConstant.MethodHandle;
&nbsp;import net.bytebuddy.utility.JavaConstant.MethodType;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;@Enhance
&nbsp;public class MethodCall implements Implementation.Composable {
&nbsp;    protected final MethodLocator.Factory methodLocator;
&nbsp;    protected final TargetHandler.Factory targetHandler;
&nbsp;    protected final List&lt;ArgumentLoader.Factory&gt; argumentLoaders;
&nbsp;    protected final MethodInvoker.Factory methodInvoker;
&nbsp;    protected final TerminationHandler.Factory terminationHandler;
&nbsp;    protected final Assigner assigner;
&nbsp;    protected final Assigner.Typing typing;
&nbsp;
&nbsp;    protected MethodCall(MethodLocator.Factory methodLocator, TargetHandler.Factory targetHandler, List&lt;ArgumentLoader.Factory&gt; argumentLoaders, MethodInvoker.Factory methodInvoker, TerminationHandler.Factory terminationHandler, Assigner assigner, Assigner.Typing typing) {
&nbsp;        this.methodLocator = methodLocator;
&nbsp;        this.targetHandler = targetHandler;
&nbsp;        this.argumentLoaders = argumentLoaders;
&nbsp;        this.methodInvoker = methodInvoker;
&nbsp;        this.terminationHandler = terminationHandler;
&nbsp;        this.assigner = assigner;
&nbsp;        this.typing = typing;
&nbsp;    }
&nbsp;
&nbsp;    public static WithoutSpecifiedTarget invoke(Method method) {
&nbsp;        return invoke((MethodDescription)(new MethodDescription.ForLoadedMethod(method)));
&nbsp;    }
&nbsp;
&nbsp;    public static WithoutSpecifiedTarget invoke(Constructor&lt;?&gt; constructor) {
&nbsp;        return invoke((MethodDescription)(new MethodDescription.ForLoadedConstructor(constructor)));
&nbsp;    }
&nbsp;
&nbsp;    public static WithoutSpecifiedTarget invoke(MethodDescription methodDescription) {
&nbsp;        return invoke((MethodLocator.Factory)(new MethodLocator.ForExplicitMethod(methodDescription)));
&nbsp;    }
&nbsp;
&nbsp;    public static WithoutSpecifiedTarget invoke(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;        return invoke(matcher, Compiler.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static WithoutSpecifiedTarget invoke(ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {
&nbsp;        return invoke((MethodLocator.Factory)(new MethodLocator.ForElementMatcher.Factory(matcher, methodGraphCompiler)));
&nbsp;    }
&nbsp;
&nbsp;    public static WithoutSpecifiedTarget invoke(MethodLocator.Factory methodLocator) {
&nbsp;        return new WithoutSpecifiedTarget(methodLocator);
&nbsp;    }
&nbsp;
&nbsp;    public static WithoutSpecifiedTarget invokeSelf() {
&nbsp;        return new WithoutSpecifiedTarget(MethodCall.MethodLocator.ForInstrumentedMethod.INSTANCE);
&nbsp;    }
&nbsp;
&nbsp;    public static MethodCall invokeSuper() {
&nbsp;        return invokeSelf().onSuper();
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public static Implementation.Composable call(Callable&lt;?&gt; callable) {</b>
<b class="fc">&nbsp;        try {</b>
<b class="fc">&nbsp;            return invoke(Callable.class.getMethod(&quot;call&quot;)).on((Object)callable, (Class)Callable.class).withAssigner(Assigner.DEFAULT, Typing.DYNAMIC);</b>
<b class="fc">&nbsp;        } catch (NoSuchMethodException var2) {</b>
<b class="fc">&nbsp;            NoSuchMethodException exception = var2;</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Could not locate Callable::call method&quot;, exception);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Implementation.Composable run(Runnable runnable) {
&nbsp;        try {
&nbsp;            return invoke(Runnable.class.getMethod(&quot;run&quot;)).on((Object)runnable, (Class)Runnable.class).withAssigner(Assigner.DEFAULT, Typing.DYNAMIC);
&nbsp;        } catch (NoSuchMethodException var2) {
&nbsp;            NoSuchMethodException exception = var2;
&nbsp;            throw new IllegalStateException(&quot;Could not locate Runnable::run method&quot;, exception);
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static MethodCall construct(Constructor&lt;?&gt; constructor) {
&nbsp;        return construct((MethodDescription)(new MethodDescription.ForLoadedConstructor(constructor)));
&nbsp;    }
&nbsp;
&nbsp;    public static MethodCall construct(MethodDescription methodDescription) {
&nbsp;        if (!methodDescription.isConstructor()) {
&nbsp;            throw new IllegalArgumentException(&quot;Not a constructor: &quot; + methodDescription);
&nbsp;        } else {
&nbsp;            return new MethodCall(new MethodLocator.ForExplicitMethod(methodDescription), MethodCall.TargetHandler.ForConstructingInvocation.Factory.INSTANCE, Collections.emptyList(), MethodCall.MethodInvoker.ForContextualInvocation.Factory.INSTANCE, MethodCall.TerminationHandler.Simple.RETURNING, Assigner.DEFAULT, Typing.STATIC);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall with(Object... argument) {
&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList(argument.length);
<b class="nc">&nbsp;        Object[] var3 = argument;</b>
&nbsp;        int var4 = argument.length;
&nbsp;
&nbsp;        for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;            Object anArgument = var3[var5];
&nbsp;            argumentLoaders.add(MethodCall.ArgumentLoader.ForStackManipulation.of(anArgument));
&nbsp;        }
&nbsp;
&nbsp;        return this.with((List)argumentLoaders);
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall with(TypeDescription... typeDescription) {
&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList(typeDescription.length);
&nbsp;        TypeDescription[] var3 = typeDescription;
&nbsp;        int var4 = typeDescription.length;
&nbsp;
&nbsp;        for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;            TypeDescription aTypeDescription = var3[var5];
<b class="fc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(ClassConstant.of(aTypeDescription), Class.class));</b>
&nbsp;        }
&nbsp;
&nbsp;        return this.with((List)argumentLoaders);
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall with(EnumerationDescription... enumerationDescription) {
&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList(enumerationDescription.length);
&nbsp;        EnumerationDescription[] var3 = enumerationDescription;
&nbsp;        int var4 = enumerationDescription.length;
&nbsp;
<b class="nc">&nbsp;        for(int var5 = 0; var5 &lt; var4; ++var5) {</b>
&nbsp;            EnumerationDescription anEnumerationDescription = var3[var5];
&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(FieldAccess.forEnumeration(anEnumerationDescription), anEnumerationDescription.getEnumerationType()));
&nbsp;        }
&nbsp;
&nbsp;        return this.with((List)argumentLoaders);
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall with(JavaConstant... javaConstant) {
&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList(javaConstant.length);
&nbsp;        JavaConstant[] var3 = javaConstant;
<b class="nc">&nbsp;        int var4 = javaConstant.length;</b>
&nbsp;
&nbsp;        for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;            JavaConstant aJavaConstant = var3[var5];
&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(new JavaConstantValue(aJavaConstant), aJavaConstant.getTypeDescription()));
&nbsp;        }
&nbsp;
&nbsp;        return this.with((List)argumentLoaders);
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall withReference(Object... argument) {
&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList(argument.length);
&nbsp;        Object[] var3 = argument;
<b class="fc">&nbsp;        int var4 = argument.length;</b>
&nbsp;
&nbsp;        for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;            Object anArgument = var3[var5];
&nbsp;            argumentLoaders.add(anArgument == null ? MethodCall.ArgumentLoader.ForNullConstant.INSTANCE : new ArgumentLoader.ForInstance.Factory(anArgument));
&nbsp;        }
&nbsp;
&nbsp;        return this.with((List)argumentLoaders);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public MethodCall withArgument(int... index) {</b>
&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList(index.length);
&nbsp;        int[] var3 = index;
&nbsp;        int var4 = index.length;
&nbsp;
&nbsp;        for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;            int anIndex = var3[var5];
&nbsp;            if (anIndex &lt; 0) {
&nbsp;                throw new IllegalArgumentException(&quot;Negative index: &quot; + anIndex);
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            argumentLoaders.add(new ArgumentLoader.ForMethodParameter.Factory(anIndex));
&nbsp;        }
&nbsp;
&nbsp;        return this.with((List)argumentLoaders);
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall withAllArguments() {
&nbsp;        return this.with(MethodCall.ArgumentLoader.ForMethodParameter.OfInstrumentedMethod.INSTANCE);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public MethodCall withArgumentArray() {</b>
<b class="nc">&nbsp;        return this.with(MethodCall.ArgumentLoader.ForMethodParameterArray.ForInstrumentedMethod.INSTANCE);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public MethodCall withArgumentArrayElements(int index) {
&nbsp;        if (index &lt; 0) {
&nbsp;            throw new IllegalArgumentException(&quot;A parameter index cannot be negative: &quot; + index);
&nbsp;        } else {
&nbsp;            return this.with(new ArgumentLoader.ForMethodParameterArrayElement.OfInvokedMethod(index));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall withArgumentArrayElements(int index, int size) {
&nbsp;        return this.withArgumentArrayElements(index, 0, size);
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public MethodCall withArgumentArrayElements(int index, int start, int size) {</b>
&nbsp;        if (index &lt; 0) {
&nbsp;            throw new IllegalArgumentException(&quot;A parameter index cannot be negative: &quot; + index);
&nbsp;        } else if (start &lt; 0) {
&nbsp;            throw new IllegalArgumentException(&quot;An array index cannot be negative: &quot; + start);
&nbsp;        } else if (size == 0) {
&nbsp;            return this;
&nbsp;        } else if (size &lt; 0) {
&nbsp;            throw new IllegalArgumentException(&quot;Size cannot be negative: &quot; + size);
&nbsp;        } else {
&nbsp;            List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList(size);
<b class="nc">&nbsp;</b>
&nbsp;            for(int position = 0; position &lt; size; ++position) {
&nbsp;                argumentLoaders.add(new ArgumentLoader.ForMethodParameterArrayElement.OfParameter(index, start + position));
&nbsp;            }
&nbsp;
&nbsp;            return this.with((List)argumentLoaders);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall withThis() {
<b class="nc">&nbsp;        return this.with(MethodCall.ArgumentLoader.ForThisReference.Factory.INSTANCE);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public MethodCall withOwnType() {</b>
&nbsp;        return this.with(MethodCall.ArgumentLoader.ForInstrumentedType.Factory.INSTANCE);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public MethodCall withField(String... name) {
&nbsp;        return this.withField(net.bytebuddy.dynamic.scaffold.FieldLocator.ForClassHierarchy.Factory.INSTANCE, name);
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall withField(FieldLocator.Factory fieldLocatorFactory, String... name) {
&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList(name.length);
&nbsp;        String[] var4 = name;
&nbsp;        int var5 = name.length;
&nbsp;
&nbsp;        for(int var6 = 0; var6 &lt; var5; ++var6) {
&nbsp;            String aName = var4[var6];
&nbsp;            argumentLoaders.add(new ArgumentLoader.ForField.Factory(aName, fieldLocatorFactory));
&nbsp;        }
&nbsp;
&nbsp;        return this.with((List)argumentLoaders);
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public MethodCall withMethodCall(MethodCall methodCall) {</b>
<b class="nc">&nbsp;        return this.with(new ArgumentLoader.ForMethodCall.Factory(methodCall));</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public MethodCall with(StackManipulation stackManipulation, Type type) {
&nbsp;        return this.with(stackManipulation, (TypeDefinition)Sort.describe(type));
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall with(StackManipulation stackManipulation, TypeDefinition typeDefinition) {
&nbsp;        return this.with(new ArgumentLoader.ForStackManipulation(stackManipulation, typeDefinition));
&nbsp;    }
&nbsp;
&nbsp;    public MethodCall with(ArgumentLoader.Factory... argumentLoader) {
&nbsp;        return this.with(Arrays.asList(argumentLoader));
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public MethodCall with(List&lt;? extends ArgumentLoader.Factory&gt; argumentLoaders) {</b>
&nbsp;        return new MethodCall(this.methodLocator, this.targetHandler, CompoundList.of(this.argumentLoaders, argumentLoaders), this.methodInvoker, this.terminationHandler, this.assigner, this.typing);
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public FieldSetting setsField(Field field) {
&nbsp;        return this.setsField((FieldDescription)(new FieldDescription.ForLoadedField(field)));
&nbsp;    }
&nbsp;
&nbsp;    public FieldSetting setsField(FieldDescription fieldDescription) {
&nbsp;        return new FieldSetting(new MethodCall(this.methodLocator, this.targetHandler, this.argumentLoaders, this.methodInvoker, new TerminationHandler.FieldSetting.Explicit(fieldDescription), this.assigner, this.typing));
&nbsp;    }
&nbsp;
&nbsp;    public FieldSetting setsField(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="nc">&nbsp;        return new FieldSetting(new MethodCall(this.methodLocator, this.targetHandler, this.argumentLoaders, this.methodInvoker, new TerminationHandler.FieldSetting.Implicit(matcher), this.assigner, this.typing));</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public Implementation.Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;        return new MethodCall(this.methodLocator, this.targetHandler, this.argumentLoaders, this.methodInvoker, this.terminationHandler, assigner, typing);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Implementation andThen(Implementation implementation) {
&nbsp;        return new Implementation.Compound(new Implementation[]{new MethodCall(this.methodLocator, this.targetHandler, this.argumentLoaders, this.methodInvoker, MethodCall.TerminationHandler.Simple.DROPPING, this.assigner, this.typing), implementation});
&nbsp;    }
&nbsp;
&nbsp;    public Implementation.Composable andThen(Implementation.Composable implementation) {
&nbsp;        return new Implementation.Compound.Composable(new MethodCall(this.methodLocator, this.targetHandler, this.argumentLoaders, this.methodInvoker, MethodCall.TerminationHandler.Simple.DROPPING, this.assigner, this.typing), implementation);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {</b>
<b class="nc">&nbsp;        InstrumentedType.Prepareable prepareable;</b>
<b class="nc">&nbsp;        for(Iterator var2 = this.argumentLoaders.iterator(); var2.hasNext(); instrumentedType = prepareable.prepare(instrumentedType)) {</b>
&nbsp;            prepareable = (InstrumentedType.Prepareable)var2.next();
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        return this.targetHandler.prepare(instrumentedType);
&nbsp;    }
&nbsp;
&nbsp;    public ByteCodeAppender appender(Implementation.Target implementationTarget) {
&nbsp;        return new Appender(implementationTarget, this.terminationHandler.make(implementationTarget.getInstrumentedType()));
&nbsp;    }
&nbsp;
&nbsp;    public boolean equals(@MaybeNull Object var1) {
&nbsp;        if (this == var1) {
&nbsp;            return true;
<b class="nc">&nbsp;        } else if (var1 == null) {</b>
<b class="nc">&nbsp;            return false;</b>
<b class="nc">&nbsp;        } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;            return false;
&nbsp;        } else if (!this.typing.equals(((MethodCall)var1).typing)) {
&nbsp;            return false;
<b class="nc">&nbsp;        } else if (!this.methodLocator.equals(((MethodCall)var1).methodLocator)) {</b>
&nbsp;            return false;
&nbsp;        } else if (!this.targetHandler.equals(((MethodCall)var1).targetHandler)) {
&nbsp;            return false;
&nbsp;        } else if (!this.argumentLoaders.equals(((MethodCall)var1).argumentLoaders)) {
&nbsp;            return false;
&nbsp;        } else if (!this.methodInvoker.equals(((MethodCall)var1).methodInvoker)) {
&nbsp;            return false;
&nbsp;        } else if (!this.terminationHandler.equals(((MethodCall)var1).terminationHandler)) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            return this.assigner.equals(((MethodCall)var1).assigner);
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;    public int hashCode() {</b>
&nbsp;        return ((((((this.getClass().hashCode() * 31 + this.methodLocator.hashCode()) * 31 + this.targetHandler.hashCode()) * 31 + this.argumentLoaders.hashCode()) * 31 + this.methodInvoker.hashCode()) * 31 + this.terminationHandler.hashCode()) * 31 + this.assigner.hashCode()) * 31 + this.typing.hashCode();
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    @Enhance(</b>
&nbsp;        includeSyntheticFields = true
&nbsp;    )
&nbsp;    protected class Appender implements ByteCodeAppender {
&nbsp;        private final Implementation.Target implementationTarget;
&nbsp;        private final MethodLocator methodLocator;
&nbsp;        private final List&lt;ArgumentLoader.ArgumentProvider&gt; argumentProviders;
&nbsp;        private final MethodInvoker methodInvoker;
&nbsp;        private final TargetHandler targetHandler;
<b class="nc">&nbsp;        private final TerminationHandler terminationHandler;</b>
&nbsp;
&nbsp;        protected Appender(Implementation.Target implementationTarget, TerminationHandler terminationHandler) {
&nbsp;            this.implementationTarget = implementationTarget;
&nbsp;            this.methodLocator = MethodCall.this.methodLocator.make(implementationTarget.getInstrumentedType());
&nbsp;            this.argumentProviders = new ArrayList(MethodCall.this.argumentLoaders.size());
&nbsp;            Iterator var4 = MethodCall.this.argumentLoaders.iterator();
&nbsp;
&nbsp;            while(var4.hasNext()) {
<b class="nc">&nbsp;                ArgumentLoader.Factory factory = (ArgumentLoader.Factory)var4.next();</b>
&nbsp;                this.argumentProviders.add(factory.make(implementationTarget));
&nbsp;            }
&nbsp;
&nbsp;            this.methodInvoker = MethodCall.this.methodInvoker.make(implementationTarget.getInstrumentedType());
&nbsp;            this.targetHandler = MethodCall.this.targetHandler.make(implementationTarget);
&nbsp;            this.terminationHandler = terminationHandler;
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;            TargetHandler.Resolved targetHandler = this.targetHandler.resolve(instrumentedMethod);
&nbsp;            return new ByteCodeAppender.Size((new StackManipulation.Compound(new StackManipulation[]{this.terminationHandler.prepare(), this.toStackManipulation(instrumentedMethod, this.toInvokedMethod(instrumentedMethod, targetHandler), targetHandler)})).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
&nbsp;        }
&nbsp;
&nbsp;        protected MethodDescription toInvokedMethod(MethodDescription instrumentedMethod, TargetHandler.Resolved targetHandler) {
&nbsp;            return this.methodLocator.resolve(targetHandler.getTypeDescription(), instrumentedMethod);
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        protected StackManipulation toStackManipulation(MethodDescription instrumentedMethod, MethodDescription invokedMethod, TargetHandler.Resolved targetHandler) {</b>
&nbsp;            List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList();
<b class="nc">&nbsp;            Iterator var5 = this.argumentProviders.iterator();</b>
&nbsp;
&nbsp;            while(var5.hasNext()) {
&nbsp;                ArgumentLoader.ArgumentProvider argumentProvider = (ArgumentLoader.ArgumentProvider)var5.next();
&nbsp;                argumentLoaders.addAll(argumentProvider.resolve(instrumentedMethod, invokedMethod));
&nbsp;            }
&nbsp;
&nbsp;            ParameterList&lt;?&gt; parameters = invokedMethod.getParameters();
&nbsp;            if (parameters.size() != argumentLoaders.size()) {
&nbsp;                throw new IllegalStateException(invokedMethod + &quot; does not accept &quot; + argumentLoaders.size() + &quot; arguments&quot;);
&nbsp;            } else {
&nbsp;                Iterator&lt;? extends ParameterDescription&gt; parameterIterator = parameters.iterator();
&nbsp;                List&lt;StackManipulation&gt; argumentInstructions = new ArrayList(argumentLoaders.size());
&nbsp;                Iterator var8 = argumentLoaders.iterator();
&nbsp;
&nbsp;                while(var8.hasNext()) {
&nbsp;                    ArgumentLoader argumentLoader = (ArgumentLoader)var8.next();
&nbsp;                    argumentInstructions.add(argumentLoader.toStackManipulation((ParameterDescription)parameterIterator.next(), MethodCall.this.assigner, MethodCall.this.typing));
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                return new StackManipulation.Compound(new StackManipulation[]{targetHandler.toStackManipulation(invokedMethod, MethodCall.this.assigner, MethodCall.this.typing), new StackManipulation.Compound(argumentInstructions), this.methodInvoker.toStackManipulation(invokedMethod, this.implementationTarget), this.terminationHandler.toStackManipulation(invokedMethod, instrumentedMethod, MethodCall.this.assigner, MethodCall.this.typing)});
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.implementationTarget.equals(((Appender)var1).implementationTarget)) {
&nbsp;                return false;
&nbsp;            } else if (!this.methodLocator.equals(((Appender)var1).methodLocator)) {
&nbsp;                return false;
&nbsp;            } else if (!this.argumentProviders.equals(((Appender)var1).argumentProviders)) {
&nbsp;                return false;
<b class="nc">&nbsp;            } else if (!this.methodInvoker.equals(((Appender)var1).methodInvoker)) {</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } else if (!this.targetHandler.equals(((Appender)var1).targetHandler)) {</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } else if (!this.terminationHandler.equals(((Appender)var1).terminationHandler)) {</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                return MethodCall.this.equals(MethodCall.this);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int hashCode() {</b>
&nbsp;            return ((((((this.getClass().hashCode() * 31 + this.implementationTarget.hashCode()) * 31 + this.methodLocator.hashCode()) * 31 + this.argumentProviders.hashCode()) * 31 + this.methodInvoker.hashCode()) * 31 + this.targetHandler.hashCode()) * 31 + this.terminationHandler.hashCode()) * 31 + MethodCall.this.hashCode();
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class FieldSetting implements Implementation.Composable {
&nbsp;        private final MethodCall methodCall;
&nbsp;
&nbsp;        protected FieldSetting(MethodCall methodCall) {
&nbsp;            this.methodCall = methodCall;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public Implementation.Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
&nbsp;            return new FieldSetting((MethodCall)this.methodCall.withAssigner(assigner, typing));
&nbsp;        }
&nbsp;
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;            return this.methodCall.prepare(instrumentedType);
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeAppender appender(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;            return new ByteCodeAppender.Compound(new ByteCodeAppender[]{this.methodCall.appender(implementationTarget), MethodCall.FieldSetting.Appender.INSTANCE});</b>
&nbsp;        }
&nbsp;
&nbsp;        public Implementation andThen(Implementation implementation) {
&nbsp;            return new Implementation.Compound(new Implementation[]{this.methodCall, implementation});
&nbsp;        }
&nbsp;
&nbsp;        public Implementation.Composable andThen(Implementation.Composable implementation) {
&nbsp;            return new Implementation.Compound.Composable(this.methodCall, implementation);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.methodCall.equals(((FieldSetting)var1).methodCall);
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int hashCode() {</b>
&nbsp;            return this.getClass().hashCode() * 31 + this.methodCall.hashCode();
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        protected static enum Appender implements ByteCodeAppender {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Appender() {
&nbsp;            }
&nbsp;
&nbsp;            public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                if (!instrumentedMethod.getReturnType().represents(Void.TYPE)) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Instrumented method &quot; + instrumentedMethod + &quot; does not return void for field setting method call&quot;);</b>
&nbsp;                } else {
&nbsp;                    return new ByteCodeAppender.Size(MethodReturn.VOID.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class WithoutSpecifiedTarget extends MethodCall {
&nbsp;        protected WithoutSpecifiedTarget(MethodLocator.Factory methodLocator) {
&nbsp;            super(methodLocator, MethodCall.TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE, Collections.emptyList(), MethodCall.MethodInvoker.ForContextualInvocation.Factory.INSTANCE, MethodCall.TerminationHandler.Simple.RETURNING, Assigner.DEFAULT, Typing.STATIC);
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public MethodCall on(Object target) {
&nbsp;            return this.on(target, target.getClass());
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T&gt; MethodCall on(T target, Class&lt;? super T&gt; type) {
&nbsp;            return new MethodCall(this.methodLocator, new TargetHandler.ForValue.Factory(target, ForLoadedType.of(type)), this.argumentLoaders, new MethodInvoker.ForVirtualInvocation.Factory(net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(type)), this.terminationHandler, this.assigner, this.typing);
&nbsp;        }
&nbsp;
&nbsp;        public MethodCall on(StackManipulation stackManipulation, Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return this.on(stackManipulation, net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        public MethodCall on(StackManipulation stackManipulation, TypeDescription typeDescription) {
&nbsp;            return new MethodCall(this.methodLocator, new TargetHandler.Simple(typeDescription, stackManipulation), this.argumentLoaders, new MethodInvoker.ForVirtualInvocation.Factory(typeDescription), this.terminationHandler, this.assigner, this.typing);
&nbsp;        }
&nbsp;
&nbsp;        public MethodCall onArgument(int index) {
&nbsp;            if (index &lt; 0) {
&nbsp;                throw new IllegalArgumentException(&quot;An argument index cannot be negative: &quot; + index);
<b class="nc">&nbsp;            } else {</b>
&nbsp;                return new MethodCall(this.methodLocator, new TargetHandler.ForMethodParameter(index), this.argumentLoaders, MethodCall.MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE, this.terminationHandler, this.assigner, this.typing);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public MethodCall onField(String name) {
&nbsp;            return this.onField(name, net.bytebuddy.dynamic.scaffold.FieldLocator.ForClassHierarchy.Factory.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        public MethodCall onField(String name, FieldLocator.Factory fieldLocatorFactory) {
<b class="fc">&nbsp;            return new MethodCall(this.methodLocator, new TargetHandler.ForField.Factory(new TargetHandler.ForField.Location.ForImplicitField(name, fieldLocatorFactory)), this.argumentLoaders, MethodCall.MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE, this.terminationHandler, this.assigner, this.typing);</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public MethodCall onField(Field field) {
&nbsp;            return this.onField((FieldDescription)(new FieldDescription.ForLoadedField(field)));
&nbsp;        }
&nbsp;
&nbsp;        public MethodCall onField(FieldDescription fieldDescription) {
&nbsp;            return new MethodCall(this.methodLocator, new TargetHandler.ForField.Factory(new TargetHandler.ForField.Location.ForExplicitField(fieldDescription)), this.argumentLoaders, MethodCall.MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE, this.terminationHandler, this.assigner, this.typing);
&nbsp;        }
&nbsp;
&nbsp;        public MethodCall onMethodCall(MethodCall methodCall) {
&nbsp;            return new MethodCall(this.methodLocator, new TargetHandler.ForMethodCall.Factory(methodCall), this.argumentLoaders, MethodCall.MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE, this.terminationHandler, this.assigner, this.typing);
&nbsp;        }
&nbsp;
&nbsp;        public MethodCall onSuper() {
&nbsp;            return new MethodCall(this.methodLocator, MethodCall.TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE, this.argumentLoaders, MethodCall.MethodInvoker.ForSuperMethodInvocation.Factory.INSTANCE, this.terminationHandler, this.assigner, this.typing);
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public MethodCall onDefault() {
&nbsp;            return new MethodCall(this.methodLocator, MethodCall.TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE, this.argumentLoaders, MethodCall.MethodInvoker.ForDefaultMethodInvocation.Factory.INSTANCE, this.terminationHandler, this.assigner, this.typing);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected interface TerminationHandler {
&nbsp;        StackManipulation prepare();
&nbsp;
&nbsp;        StackManipulation toStackManipulation(MethodDescription var1, MethodDescription var2, Assigner var3, Assigner.Typing var4);
<b class="nc">&nbsp;</b>
&nbsp;        @Enhance
&nbsp;        public static class FieldSetting implements TerminationHandler {
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            protected FieldSetting(FieldDescription fieldDescription) {
&nbsp;                this.fieldDescription = fieldDescription;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation prepare() {
&nbsp;                return (StackManipulation)(this.fieldDescription.isStatic() ? Trivial.INSTANCE : MethodVariableAccess.loadThis());
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor() ? invokedMethod.getDeclaringType().asGenericType() : invokedMethod.getReturnType(), this.fieldDescription.getType(), typing);
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign result of &quot; + invokedMethod + &quot; to &quot; + this.fieldDescription);
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    return new StackManipulation.Compound(new StackManipulation[]{stackManipulation, FieldAccess.forField(this.fieldDescription).write()});
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.fieldDescription.equals(((FieldSetting)var1).fieldDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            @Enhance</b>
&nbsp;            protected static class Implicit implements Factory {
&nbsp;                private final ElementMatcher&lt;? super FieldDescription&gt; matcher;
&nbsp;
&nbsp;                protected Implicit(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
&nbsp;                    this.matcher = matcher;
&nbsp;                }
&nbsp;
&nbsp;                public TerminationHandler make(TypeDescription instrumentedType) {
&nbsp;                    TypeDefinition current = instrumentedType;
&nbsp;
&nbsp;                    do {
&nbsp;                        FieldList&lt;?&gt; candidates = (FieldList)((TypeDefinition)current).getDeclaredFields().filter(ElementMatchers.isVisibleTo(instrumentedType).and(this.matcher));
<b class="nc">&nbsp;                        if (candidates.size() == 1) {</b>
&nbsp;                            return new FieldSetting((FieldDescription)candidates.getOnly());
&nbsp;                        }
&nbsp;
&nbsp;                        if (candidates.size() == 2) {
&nbsp;                            throw new IllegalStateException(this.matcher + &quot; is ambiguous and resolved: &quot; + candidates);
&nbsp;                        }
&nbsp;
&nbsp;                        current = ((TypeDefinition)current).getSuperClass();
&nbsp;                    } while(current != null);
&nbsp;
&nbsp;                    throw new IllegalStateException(this.matcher + &quot; does not locate any accessible fields for &quot; + instrumentedType);
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.matcher.equals(((Implicit)var1).matcher);
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public int hashCode() {</b>
<b class="fc">&nbsp;                    return this.getClass().hashCode() * 31 + this.matcher.hashCode();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Explicit implements Factory {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                protected Explicit(FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming declaring type for type member.&quot;
&nbsp;                )
&nbsp;                public TerminationHandler make(TypeDescription instrumentedType) {
&nbsp;                    if (!this.fieldDescription.isStatic() &amp;&amp; !instrumentedType.isAssignableTo(this.fieldDescription.getDeclaringType().asErasure())) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot set &quot; + this.fieldDescription + &quot; from &quot; + instrumentedType);
&nbsp;                    } else if (!this.fieldDescription.isVisibleTo(instrumentedType)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access &quot; + this.fieldDescription + &quot; from &quot; + instrumentedType);
&nbsp;                    } else {
&nbsp;                        return new FieldSetting(this.fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription.equals(((Explicit)var1).fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum Simple implements TerminationHandler, Factory {
&nbsp;            RETURNING {
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                    StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor() ? invokedMethod.getDeclaringType().asGenericType() : invokedMethod.getReturnType(), instrumentedMethod.getReturnType(), typing);
&nbsp;                    if (!stackManipulation.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot return &quot; + invokedMethod.getReturnType() + &quot; from &quot; + instrumentedMethod);
&nbsp;                    } else {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{stackManipulation, MethodReturn.of(instrumentedMethod.getReturnType())});
&nbsp;                    }
&nbsp;                }
&nbsp;            },
&nbsp;            DROPPING {
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                    return Removal.of((TypeDefinition)(invokedMethod.isConstructor() ? invokedMethod.getDeclaringType() : invokedMethod.getReturnType()));
&nbsp;                }
&nbsp;            },
&nbsp;            IGNORING {
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                    return Trivial.INSTANCE;
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            private Simple() {
&nbsp;            }
&nbsp;
&nbsp;            public TerminationHandler make(TypeDescription instrumentedType) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation prepare() {
&nbsp;                return Trivial.INSTANCE;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            TerminationHandler make(TypeDescription var1);
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    protected interface MethodInvoker {</b>
<b class="fc">&nbsp;        StackManipulation toStackManipulation(MethodDescription var1, Implementation.Target var2);</b>
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForDefaultMethodInvocation implements MethodInvoker {
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
<b class="fc">&nbsp;            protected ForDefaultMethodInvocation(TypeDescription instrumentedType) {</b>
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
&nbsp;                if (!invokedMethod.isInvokableOn(this.instrumentedType)) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as default method of &quot; + this.instrumentedType);
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    StackManipulation stackManipulation = implementationTarget.invokeDefault(invokedMethod.asSignatureToken(), invokedMethod.getDeclaringType().asErasure()).withCheckedCompatibilityTo(invokedMethod.asTypeToken());
&nbsp;                    if (!stackManipulation.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + this.instrumentedType);
&nbsp;                    } else {
&nbsp;                        return stackManipulation;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedType.equals(((ForDefaultMethodInvocation)var1).instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.instrumentedType.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
&nbsp;                    return new ForDefaultMethodInvocation(instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForSuperMethodInvocation implements MethodInvoker {
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            protected ForSuperMethodInvocation(TypeDescription instrumentedType) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
&nbsp;                if (!invokedMethod.isInvokableOn(implementationTarget.getOriginType().asErasure())) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as super method of &quot; + this.instrumentedType);
&nbsp;                } else {
&nbsp;                    StackManipulation stackManipulation = implementationTarget.invokeDominant(invokedMethod.asSignatureToken()).withCheckedCompatibilityTo(invokedMethod.asTypeToken());
&nbsp;                    if (!stackManipulation.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as a super method&quot;);
&nbsp;                    } else {
&nbsp;                        return stackManipulation;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedType.equals(((ForSuperMethodInvocation)var1).instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.instrumentedType.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
&nbsp;                    if (instrumentedType.getSuperClass() == null) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke super method for &quot; + instrumentedType);
&nbsp;                    } else {
&nbsp;                        return new ForSuperMethodInvocation(instrumentedType);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForVirtualInvocation implements MethodInvoker {
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            protected ForVirtualInvocation(TypeDescription typeDescription) {
&nbsp;                this.typeDescription = typeDescription;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
&nbsp;                if (!invokedMethod.isInvokableOn(this.typeDescription)) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + this.typeDescription);
&nbsp;                } else {
&nbsp;                    return MethodInvocation.invoke(invokedMethod).virtual(this.typeDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.typeDescription.equals(((ForVirtualInvocation)var1).typeDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                protected Factory(TypeDescription typeDescription) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
&nbsp;                    if (!this.typeDescription.asErasure().isAccessibleTo(instrumentedType)) {
&nbsp;                        throw new IllegalStateException(this.typeDescription + &quot; is not accessible to &quot; + instrumentedType);
&nbsp;                    } else {
&nbsp;                        return new ForVirtualInvocation(this.typeDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typeDescription.equals(((Factory)var1).typeDescription);
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            protected static enum WithImplicitType implements MethodInvoker, Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private WithImplicitType() {
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
&nbsp;                    if (invokedMethod.isAccessibleTo(implementationTarget.getInstrumentedType()) &amp;&amp; invokedMethod.isVirtual()) {
<b class="nc">&nbsp;                        return MethodInvocation.invoke(invokedMethod);</b>
&nbsp;                    } else {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; virtually&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @Enhance</b>
&nbsp;        public static class ForContextualInvocation implements MethodInvoker {
<b class="nc">&nbsp;            private final TypeDescription instrumentedType;</b>
&nbsp;
&nbsp;            protected ForContextualInvocation(TypeDescription instrumentedType) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
&nbsp;                if (invokedMethod.isVirtual() &amp;&amp; !invokedMethod.isInvokableOn(this.instrumentedType)) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + this.instrumentedType);
&nbsp;                } else {
&nbsp;                    return (StackManipulation)(invokedMethod.isVirtual() ? MethodInvocation.invoke(invokedMethod).virtual(this.instrumentedType) : MethodInvocation.invoke(invokedMethod));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedType.equals(((ForContextualInvocation)var1).instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.instrumentedType.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
&nbsp;                    return new ForContextualInvocation(instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            MethodInvoker make(TypeDescription var1);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected interface TargetHandler {
&nbsp;        Resolved resolve(MethodDescription var1);
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForMethodCall implements TargetHandler {
&nbsp;            private final Appender appender;
&nbsp;
&nbsp;            protected ForMethodCall(Appender appender) {
&nbsp;                this.appender = appender;
&nbsp;            }
&nbsp;
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
&nbsp;                Resolved targetHandler = this.appender.targetHandler.resolve(instrumentedMethod);
&nbsp;                return new Resolved(this.appender, this.appender.toInvokedMethod(instrumentedMethod, targetHandler), instrumentedMethod, targetHandler);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.appender.equals(((ForMethodCall)var1).appender);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.appender.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory {
&nbsp;                private final MethodCall methodCall;
&nbsp;
&nbsp;                public Factory(MethodCall methodCall) {
&nbsp;                    this.methodCall = methodCall;
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return this.methodCall.prepare(instrumentedType);
&nbsp;                }
&nbsp;
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
&nbsp;                    return new ForMethodCall(this.methodCall.new Appender(implementationTarget, MethodCall.TerminationHandler.Simple.IGNORING));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.methodCall.equals(((Factory)var1).methodCall);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.methodCall.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Resolved implements Resolved {
&nbsp;                private final Appender appender;
&nbsp;                private final MethodDescription methodDescription;
&nbsp;                private final MethodDescription instrumentedMethod;
&nbsp;                private final Resolved targetHandler;
&nbsp;
&nbsp;                protected Resolved(Appender appender, MethodDescription methodDescription, MethodDescription instrumentedMethod, Resolved targetHandler) {
&nbsp;                    this.appender = appender;
&nbsp;                    this.methodDescription = methodDescription;
&nbsp;                    this.instrumentedMethod = instrumentedMethod;
&nbsp;                    this.targetHandler = targetHandler;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription getTypeDescription() {
&nbsp;                    return this.methodDescription.isConstructor() ? this.methodDescription.getDeclaringType().asErasure() : this.methodDescription.getReturnType().asErasure();
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                    StackManipulation stackManipulation = assigner.assign(this.methodDescription.isConstructor() ? this.methodDescription.getDeclaringType().asGenericType() : this.methodDescription.getReturnType(), invokedMethod.getDeclaringType().asGenericType(), typing);
&nbsp;                    if (!stackManipulation.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + (this.methodDescription.isConstructor() ? this.methodDescription.getDeclaringType() : this.methodDescription.getReturnType()));
&nbsp;                    } else {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{this.appender.toStackManipulation(this.instrumentedMethod, this.methodDescription, this.targetHandler), stackManipulation});
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.appender.equals(((Resolved)var1).appender)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.methodDescription.equals(((Resolved)var1).methodDescription)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.instrumentedMethod.equals(((Resolved)var1).instrumentedMethod)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.targetHandler.equals(((Resolved)var1).targetHandler);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (((this.getClass().hashCode() * 31 + this.appender.hashCode()) * 31 + this.methodDescription.hashCode()) * 31 + this.instrumentedMethod.hashCode()) * 31 + this.targetHandler.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        @Enhance</b>
<b class="fc">&nbsp;        public static class ForMethodParameter implements TargetHandler, Factory {</b>
<b class="fc">&nbsp;            private final int index;</b>
&nbsp;
&nbsp;            protected ForMethodParameter(int index) {
&nbsp;                this.index = index;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {</b>
<b class="fc">&nbsp;                return instrumentedType;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;            public TargetHandler make(Implementation.Target implementationTarget) {</b>
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
&nbsp;                if (this.index &gt;= instrumentedMethod.getParameters().size()) {
&nbsp;                    throw new IllegalArgumentException(instrumentedMethod + &quot; does not have a parameter with index &quot; + this.index);
&nbsp;                } else {
&nbsp;                    return new Resolved((ParameterDescription)instrumentedMethod.getParameters().get(this.index));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.index == ((ForMethodParameter)var1).index;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.index;
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Resolved implements Resolved {
&nbsp;                private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;                protected Resolved(ParameterDescription parameterDescription) {
&nbsp;                    this.parameterDescription = parameterDescription;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription getTypeDescription() {
&nbsp;                    return this.parameterDescription.getType().asErasure();
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                    StackManipulation stackManipulation = assigner.assign(this.parameterDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);
&nbsp;                    if (!stackManipulation.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + this.parameterDescription.getType());
&nbsp;                    } else {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.load(this.parameterDescription), stackManipulation});
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.parameterDescription.equals(((Resolved)var1).parameterDescription);
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.parameterDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        @Enhance
&nbsp;        public static class ForField implements TargetHandler, Resolved {
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            protected ForField(FieldDescription fieldDescription) {
&nbsp;                this.fieldDescription = fieldDescription;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getTypeDescription() {
<b class="pc">&nbsp;                return this.fieldDescription.getType().asErasure();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                if (invokedMethod.isMethod() &amp;&amp; invokedMethod.isVirtual() &amp;&amp; invokedMethod.isVisibleTo(this.fieldDescription.getType().asErasure())) {</b>
&nbsp;                    StackManipulation stackManipulation = assigner.assign(this.fieldDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);
&nbsp;                    if (!stackManipulation.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + this.fieldDescription);
&nbsp;                    } else {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{(StackManipulation)(!invokedMethod.isStatic() &amp;&amp; !this.fieldDescription.isStatic() ? MethodVariableAccess.loadThis() : Trivial.INSTANCE), FieldAccess.forField(this.fieldDescription).read(), stackManipulation});
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + this.fieldDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.fieldDescription.equals(((ForField)var1).fieldDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory {
&nbsp;                private final Location location;
&nbsp;
&nbsp;                protected Factory(Location location) {
&nbsp;                    this.location = location;
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming declaring type for type member.&quot;
&nbsp;                )
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
&nbsp;                    FieldDescription fieldDescription = this.location.resolve(implementationTarget.getInstrumentedType());
&nbsp;                    if (!fieldDescription.isStatic() &amp;&amp; !implementationTarget.getInstrumentedType().isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + implementationTarget.getInstrumentedType());
&nbsp;                    } else {
&nbsp;                        return new ForField(fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.location.equals(((Factory)var1).location);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.location.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected interface Location {
&nbsp;                FieldDescription resolve(TypeDescription var1);
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForExplicitField implements Location {
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                    protected ForExplicitField(FieldDescription fieldDescription) {
&nbsp;                        this.fieldDescription = fieldDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public FieldDescription resolve(TypeDescription instrumentedType) {
&nbsp;                        return this.fieldDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.fieldDescription.equals(((ForExplicitField)var1).fieldDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForImplicitField implements Location {
&nbsp;                    private final String name;
&nbsp;                    private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;                    protected ForImplicitField(String name, FieldLocator.Factory fieldLocatorFactory) {
&nbsp;                        this.name = name;
&nbsp;                        this.fieldLocatorFactory = fieldLocatorFactory;
&nbsp;                    }
&nbsp;
&nbsp;                    public FieldDescription resolve(TypeDescription instrumentedType) {
&nbsp;                        FieldLocator.Resolution resolution = this.fieldLocatorFactory.make(instrumentedType).locate(this.name);
&nbsp;                        if (!resolution.isResolved()) {
&nbsp;                            throw new IllegalStateException(&quot;Could not locate field name &quot; + this.name + &quot; on &quot; + instrumentedType);
&nbsp;                        } else {
&nbsp;                            return resolution.getField();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.name.equals(((ForImplicitField)var1).name)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.fieldLocatorFactory.equals(((ForImplicitField)var1).fieldLocatorFactory);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.fieldLocatorFactory.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForValue implements TargetHandler, Resolved {
&nbsp;            private final FieldDescription.InDefinedShape fieldDescription;
&nbsp;
&nbsp;            protected ForValue(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;                this.fieldDescription = fieldDescription;
&nbsp;            }
&nbsp;
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getTypeDescription() {
&nbsp;                return this.fieldDescription.getType().asErasure();
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = assigner.assign(this.fieldDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + this.fieldDescription);
&nbsp;                } else {
&nbsp;                    return new StackManipulation.Compound(new StackManipulation[]{FieldAccess.forField(this.fieldDescription).read(), stackManipulation});
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.fieldDescription.equals(((ForValue)var1).fieldDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory {
&nbsp;                private static final String FIELD_PREFIX = &quot;invocationTarget&quot;;
&nbsp;                private final Object target;
&nbsp;                private final TypeDescription.Generic fieldType;
&nbsp;                @ValueHandling(net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected Factory(Object target, TypeDescription.Generic fieldType) {
&nbsp;                    this.target = target;
&nbsp;                    this.fieldType = fieldType;
&nbsp;                    this.name = &quot;invocationTarget$&quot; + RandomString.hashOf(target);
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType.withAuxiliaryField(new FieldDescription.Token(this.name, 4169, this.fieldType), this.target);
&nbsp;                }
&nbsp;
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
&nbsp;                    return new ForValue((FieldDescription.InDefinedShape)((FieldList)implementationTarget.getInstrumentedType().getDeclaredFields().filter(ElementMatchers.named(this.name))).getOnly());
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.target.equals(((Factory)var1).target)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldType.equals(((Factory)var1).fieldType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.fieldType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForConstructingInvocation implements TargetHandler, Resolved {
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            protected ForConstructingInvocation(TypeDescription instrumentedType) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getTypeDescription() {
&nbsp;                return this.instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                return new StackManipulation.Compound(new StackManipulation[]{TypeCreation.of(invokedMethod.getDeclaringType().asErasure()), Duplication.SINGLE});
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedType.equals(((ForConstructingInvocation)var1).instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.instrumentedType.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
&nbsp;                    return new ForConstructingInvocation(implementationTarget.getInstrumentedType());
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForSelfOrStaticInvocation implements TargetHandler {
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            protected ForSelfOrStaticInvocation(TypeDescription instrumentedType) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
&nbsp;                return new Resolved(this.instrumentedType, instrumentedMethod);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedType.equals(((ForSelfOrStaticInvocation)var1).instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.instrumentedType.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Factory implements Factory {
&nbsp;                INSTANCE;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                private Factory() {</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ForSelfOrStaticInvocation(implementationTarget.getInstrumentedType());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Resolved implements Resolved {
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final MethodDescription instrumentedMethod;
&nbsp;
<b class="nc">&nbsp;                protected Resolved(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {</b>
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.instrumentedMethod = instrumentedMethod;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription getTypeDescription() {
&nbsp;                    return this.instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming declaring type for type member.&quot;
&nbsp;                )
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                    if (this.instrumentedMethod.isStatic() &amp;&amp; !invokedMethod.isStatic() &amp;&amp; !invokedMethod.isConstructor()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; from &quot; + this.instrumentedMethod);
&nbsp;                    } else if (invokedMethod.isConstructor() &amp;&amp; (!this.instrumentedMethod.isConstructor() || !this.instrumentedType.equals(invokedMethod.getDeclaringType().asErasure()) &amp;&amp; (this.instrumentedType.getSuperClass() == null || !this.instrumentedType.getSuperClass().asErasure().equals(invokedMethod.getDeclaringType().asErasure())))) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; from &quot; + this.instrumentedMethod + &quot; in &quot; + this.instrumentedType);
&nbsp;                    } else {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{(StackManipulation)(invokedMethod.isStatic() ? Trivial.INSTANCE : MethodVariableAccess.loadThis()), (StackManipulation)(invokedMethod.isConstructor() ? Duplication.SINGLE : Trivial.INSTANCE)});
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.instrumentedType.equals(((Resolved)var1).instrumentedType)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.instrumentedMethod.equals(((Resolved)var1).instrumentedMethod);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.instrumentedType.hashCode()) * 31 + this.instrumentedMethod.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Simple implements TargetHandler, Factory, Resolved {
&nbsp;            private final TypeDescription typeDescription;
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            protected Simple(TypeDescription typeDescription, StackManipulation stackManipulation) {
&nbsp;                this.typeDescription = typeDescription;
&nbsp;                this.stackManipulation = stackManipulation;
&nbsp;            }
&nbsp;
&nbsp;            public TargetHandler make(Implementation.Target implementationTarget) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getTypeDescription() {
&nbsp;                return this.typeDescription;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
&nbsp;                return this.stackManipulation;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typeDescription.equals(((Simple)var1).typeDescription)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.stackManipulation.equals(((Simple)var1).stackManipulation);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.typeDescription.hashCode()) * 31 + this.stackManipulation.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory extends InstrumentedType.Prepareable {
&nbsp;            TargetHandler make(Implementation.Target var1);
&nbsp;        }
&nbsp;
&nbsp;        public interface Resolved {
&nbsp;            TypeDescription getTypeDescription();
&nbsp;
&nbsp;            StackManipulation toStackManipulation(MethodDescription var1, Assigner var2, Assigner.Typing var3);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface ArgumentLoader {
&nbsp;        StackManipulation toStackManipulation(ParameterDescription var1, Assigner var2, Assigner.Typing var3);
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForStackManipulation implements ArgumentLoader, ArgumentProvider, Factory {
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;            private final TypeDefinition typeDefinition;
&nbsp;
&nbsp;            public ForStackManipulation(StackManipulation stackManipulation, Type type) {
&nbsp;                this(stackManipulation, (TypeDefinition)Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public ForStackManipulation(StackManipulation stackManipulation, TypeDefinition typeDefinition) {
&nbsp;                this.stackManipulation = stackManipulation;
&nbsp;                this.typeDefinition = typeDefinition;
&nbsp;            }
&nbsp;
&nbsp;            public static Factory of(@MaybeNull Object value) {
&nbsp;                if (value == null) {
&nbsp;                    return MethodCall.ArgumentLoader.ForNullConstant.INSTANCE;
&nbsp;                } else if (value instanceof Boolean) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Boolean)value), Boolean.TYPE);
&nbsp;                } else if (value instanceof Byte) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Byte)value), Byte.TYPE);
&nbsp;                } else if (value instanceof Short) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Short)value), Short.TYPE);
&nbsp;                } else if (value instanceof Character) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Character)value), Character.TYPE);
&nbsp;                } else if (value instanceof Integer) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Integer)value), Integer.TYPE);
&nbsp;                } else if (value instanceof Long) {
&nbsp;                    return new ForStackManipulation(LongConstant.forValue((Long)value), Long.TYPE);
&nbsp;                } else if (value instanceof Float) {
&nbsp;                    return new ForStackManipulation(FloatConstant.forValue((Float)value), Float.TYPE);
&nbsp;                } else if (value instanceof Double) {
&nbsp;                    return new ForStackManipulation(DoubleConstant.forValue((Double)value), Double.TYPE);
&nbsp;                } else if (value instanceof String) {
&nbsp;                    return new ForStackManipulation(new TextConstant((String)value), String.class);
&nbsp;                } else if (value instanceof Class) {
&nbsp;                    return new ForStackManipulation(ClassConstant.of(net.bytebuddy.description.type.TypeDescription.ForLoadedType.of((Class)value)), Class.class);
&nbsp;                } else if (value instanceof TypeDescription) {
&nbsp;                    return new ForStackManipulation(ClassConstant.of((TypeDescription)value), Class.class);
&nbsp;                } else if (value instanceof Enum) {
&nbsp;                    EnumerationDescription enumerationDescription = new EnumerationDescription.ForLoadedEnumeration((Enum)value);
&nbsp;                    return new ForStackManipulation(FieldAccess.forEnumeration(enumerationDescription), enumerationDescription.getEnumerationType());
&nbsp;                } else if (value instanceof EnumerationDescription) {
&nbsp;                    return new ForStackManipulation(FieldAccess.forEnumeration((EnumerationDescription)value), ((EnumerationDescription)value).getEnumerationType());
&nbsp;                } else if (JavaType.METHOD_HANDLE.isInstance(value)) {
&nbsp;                    return new ForStackManipulation(new JavaConstantValue(MethodHandle.ofLoaded(value)), JavaType.METHOD_HANDLE.getTypeStub());
&nbsp;                } else if (JavaType.METHOD_TYPE.isInstance(value)) {
&nbsp;                    return new ForStackManipulation(new JavaConstantValue(MethodType.ofLoaded(value)), JavaType.METHOD_TYPE.getTypeStub());
&nbsp;                } else {
&nbsp;                    return (Factory)(value instanceof JavaConstant ? new ForStackManipulation(new JavaConstantValue((JavaConstant)value), ((JavaConstant)value).getTypeDescription()) : new ForInstance.Factory(value));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                return Collections.singletonList(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation assignment = assigner.assign(this.typeDefinition.asGenericType(), target.getType(), typing);
&nbsp;                if (!assignment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + this.typeDefinition);
&nbsp;                } else {
&nbsp;                    return new StackManipulation.Compound(new StackManipulation[]{this.stackManipulation, assignment});
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.stackManipulation.equals(((ForStackManipulation)var1).stackManipulation)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.typeDefinition.equals(((ForStackManipulation)var1).typeDefinition);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.stackManipulation.hashCode()) * 31 + this.typeDefinition.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForMethodCall implements ArgumentLoader {
&nbsp;            private final Appender appender;
&nbsp;            private final MethodDescription methodDescription;
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;            private final TargetHandler.Resolved targetHandler;
&nbsp;
&nbsp;            public ForMethodCall(Appender appender, MethodDescription methodDescription, MethodDescription instrumentedMethod, TargetHandler.Resolved targetHandler) {
&nbsp;                this.appender = appender;
&nbsp;                this.methodDescription = methodDescription;
&nbsp;                this.instrumentedMethod = instrumentedMethod;
&nbsp;                this.targetHandler = targetHandler;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(new StackManipulation[]{this.appender.toStackManipulation(this.instrumentedMethod, this.methodDescription, this.targetHandler), assigner.assign(this.methodDescription.isConstructor() ? this.methodDescription.getDeclaringType().asGenericType() : this.methodDescription.getReturnType(), target.getType(), typing)});
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign return type of &quot; + this.methodDescription + &quot; to &quot; + target);
&nbsp;                } else {
&nbsp;                    return stackManipulation;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.appender.equals(((ForMethodCall)var1).appender)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.methodDescription.equals(((ForMethodCall)var1).methodDescription)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.instrumentedMethod.equals(((ForMethodCall)var1).instrumentedMethod)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.targetHandler.equals(((ForMethodCall)var1).targetHandler);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (((this.getClass().hashCode() * 31 + this.appender.hashCode()) * 31 + this.methodDescription.hashCode()) * 31 + this.instrumentedMethod.hashCode()) * 31 + this.targetHandler.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory {
&nbsp;                private final MethodCall methodCall;
&nbsp;
&nbsp;                public Factory(MethodCall methodCall) {
&nbsp;                    this.methodCall = methodCall;
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return this.methodCall.prepare(instrumentedType);
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return new ArgumentProvider(this.methodCall.new Appender(implementationTarget, MethodCall.TerminationHandler.Simple.IGNORING));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.methodCall.equals(((Factory)var1).methodCall);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.methodCall.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class ArgumentProvider implements ArgumentProvider {
&nbsp;                private final Appender appender;
&nbsp;
&nbsp;                protected ArgumentProvider(Appender appender) {
&nbsp;                    this.appender = appender;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    TargetHandler.Resolved targetHandler = this.appender.targetHandler.resolve(instrumentedMethod);
&nbsp;                    return Collections.singletonList(new ForMethodCall(this.appender, this.appender.toInvokedMethod(instrumentedMethod, targetHandler), instrumentedMethod, targetHandler));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.appender.equals(((ArgumentProvider)var1).appender);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.appender.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForField implements ArgumentLoader {
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            public ForField(FieldDescription fieldDescription, MethodDescription instrumentedMethod) {
&nbsp;                this.fieldDescription = fieldDescription;
&nbsp;                this.instrumentedMethod = instrumentedMethod;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                if (!this.fieldDescription.isStatic() &amp;&amp; this.instrumentedMethod.isStatic()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access non-static &quot; + this.fieldDescription + &quot; from &quot; + this.instrumentedMethod);
&nbsp;                } else {
&nbsp;                    StackManipulation stackManipulation = new StackManipulation.Compound(new StackManipulation[]{(StackManipulation)(this.fieldDescription.isStatic() ? Trivial.INSTANCE : MethodVariableAccess.loadThis()), FieldAccess.forField(this.fieldDescription).read(), assigner.assign(this.fieldDescription.getType(), target.getType(), typing)});
&nbsp;                    if (!stackManipulation.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + this.fieldDescription + &quot; to &quot; + target);
&nbsp;                    } else {
&nbsp;                        return stackManipulation;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.fieldDescription.equals(((ForField)var1).fieldDescription)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedMethod.equals(((ForField)var1).instrumentedMethod);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.fieldDescription.hashCode()) * 31 + this.instrumentedMethod.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory {
&nbsp;                private final String name;
&nbsp;                private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;                public Factory(String name, FieldLocator.Factory fieldLocatorFactory) {
&nbsp;                    this.name = name;
&nbsp;                    this.fieldLocatorFactory = fieldLocatorFactory;
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    FieldLocator.Resolution resolution = this.fieldLocatorFactory.make(implementationTarget.getInstrumentedType()).locate(this.name);
&nbsp;                    if (!resolution.isResolved()) {
&nbsp;                        throw new IllegalStateException(&quot;Could not locate field &#39;&quot; + this.name + &quot;&#39; on &quot; + implementationTarget.getInstrumentedType());
&nbsp;                    } else {
&nbsp;                        return new ArgumentProvider(resolution.getField());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.name.equals(((Factory)var1).name)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldLocatorFactory.equals(((Factory)var1).fieldLocatorFactory);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.fieldLocatorFactory.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class ArgumentProvider implements ArgumentProvider {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                protected ArgumentProvider(FieldDescription fieldDescription) {
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    return Collections.singletonList(new ForField(this.fieldDescription, instrumentedMethod));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription.equals(((ArgumentProvider)var1).fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForInstance implements ArgumentLoader, ArgumentProvider {
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            public ForInstance(FieldDescription fieldDescription) {
&nbsp;                this.fieldDescription = fieldDescription;
&nbsp;            }
&nbsp;
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                return Collections.singletonList(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(new StackManipulation[]{FieldAccess.forField(this.fieldDescription).read(), assigner.assign(this.fieldDescription.getType(), target.getType(), typing)});
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + this.fieldDescription.getType() + &quot; to &quot; + target);
&nbsp;                } else {
&nbsp;                    return stackManipulation;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.fieldDescription.equals(((ForInstance)var1).fieldDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory {
&nbsp;                private static final String FIELD_PREFIX = &quot;methodCall&quot;;
&nbsp;                private final Object value;
&nbsp;                @ValueHandling(net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;                private final String name;
&nbsp;
&nbsp;                public Factory(Object value) {
&nbsp;                    this.value = value;
&nbsp;                    this.name = &quot;methodCall$&quot; + RandomString.hashOf(value);
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType.withAuxiliaryField(new FieldDescription.Token(this.name, 4105, ForLoadedType.of(this.value.getClass())), this.value);
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return new ForInstance((FieldDescription)((FieldList)implementationTarget.getInstrumentedType().getDeclaredFields().filter(ElementMatchers.named(this.name))).getOnly());
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.value.equals(((Factory)var1).value);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.value.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForMethodParameterArrayElement implements ArgumentLoader {
&nbsp;            private final ParameterDescription parameterDescription;
&nbsp;            private final int index;
&nbsp;
&nbsp;            public ForMethodParameterArrayElement(ParameterDescription parameterDescription, int index) {
<b class="fc">&nbsp;                this.parameterDescription = parameterDescription;</b>
<b class="fc">&nbsp;                this.index = index;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
<b class="fc">&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {</b>
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.load(this.parameterDescription), IntegerConstant.forValue(this.index), ArrayAccess.of(this.parameterDescription.getType().getComponentType()).load(), assigner.assign(this.parameterDescription.getType().getComponentType(), target.getType(), typing)});
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + this.parameterDescription.getType().getComponentType() + &quot; to &quot; + target);
&nbsp;                } else {
&nbsp;                    return stackManipulation;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.index != ((ForMethodParameterArrayElement)var1).index) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.parameterDescription.equals(((ForMethodParameterArrayElement)var1).parameterDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.parameterDescription.hashCode()) * 31 + this.index;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            @Enhance</b>
<b class="fc">&nbsp;            public static class OfInvokedMethod implements Factory, ArgumentProvider {</b>
<b class="fc">&nbsp;                private final int index;</b>
<b class="fc">&nbsp;</b>
&nbsp;                public OfInvokedMethod(int index) {
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="pc">&nbsp;                    if (instrumentedMethod.getParameters().size() &lt;= this.index) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not declare a parameter with index &quot; + this.index + &quot;, &quot; + instrumentedMethod.getParameters().size() + &quot; defined&quot;);</b>
<b class="pc">&nbsp;                    } else if (!((ParameterDescription)instrumentedMethod.getParameters().get(this.index)).getType().isArray()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access an item from non-array parameter &quot; + instrumentedMethod.getParameters().get(this.index) + &quot; at index &quot; + this.index);</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList(invokedMethod.getParameters().size());</b>
<b class="nc">&nbsp;</b>
&nbsp;                        for(int index = 0; index &lt; invokedMethod.getParameters().size(); ++index) {
<b class="fc">&nbsp;                            argumentLoaders.add(new ForMethodParameterArrayElement((ParameterDescription)instrumentedMethod.getParameters().get(this.index), index));</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;
<b class="fc">&nbsp;                        return argumentLoaders;</b>
<b class="pc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        return this.index == ((OfInvokedMethod)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public int hashCode() {</b>
&nbsp;                    return this.getClass().hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
<b class="fc">&nbsp;            public static class OfParameter implements Factory, ArgumentProvider {</b>
&nbsp;                private final int index;
&nbsp;                private final int arrayIndex;
&nbsp;
&nbsp;                public OfParameter(int index, int arrayIndex) {
&nbsp;                    this.index = index;
&nbsp;                    this.arrayIndex = arrayIndex;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    if (instrumentedMethod.getParameters().size() &lt;= this.index) {
&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not declare a parameter with index &quot; + this.index + &quot;, &quot; + instrumentedMethod.getParameters().size() + &quot; defined&quot;);
&nbsp;                    } else if (!((ParameterDescription)instrumentedMethod.getParameters().get(this.index)).getType().isArray()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access an item from non-array parameter &quot; + instrumentedMethod.getParameters().get(this.index) + &quot; at index &quot; + this.index);
&nbsp;                    } else {
&nbsp;                        return Collections.singletonList(new ForMethodParameterArrayElement((ParameterDescription)instrumentedMethod.getParameters().get(this.index), this.arrayIndex));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((OfParameter)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.arrayIndex == ((OfParameter)var1).arrayIndex;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.index) * 31 + this.arrayIndex;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForMethodParameterArray implements ArgumentLoader {
&nbsp;            private final ParameterList&lt;?&gt; parameters;
&nbsp;
&nbsp;            public ForMethodParameterArray(ParameterList&lt;?&gt; parameters) {
&nbsp;                this.parameters = parameters;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                TypeDescription.Generic componentType;
&nbsp;                if (target.getType().represents(Object.class)) {
&nbsp;                    componentType = ForLoadedType.of(Object.class);
&nbsp;                } else {
&nbsp;                    if (!target.getType().isArray()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot set method parameter array for non-array type: &quot; + target);
&nbsp;                    }
&nbsp;
&nbsp;                    componentType = target.getType().getComponentType();
&nbsp;                }
&nbsp;
&nbsp;                List&lt;StackManipulation&gt; stackManipulations = new ArrayList(this.parameters.size());
&nbsp;                Iterator var6 = this.parameters.iterator();
&nbsp;
&nbsp;                while(var6.hasNext()) {
&nbsp;                    ParameterDescription parameter = (ParameterDescription)var6.next();
&nbsp;                    StackManipulation stackManipulation = new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.load(parameter), assigner.assign(parameter.getType(), componentType, typing)});
&nbsp;                    if (!stackManipulation.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + parameter + &quot; to &quot; + componentType);
&nbsp;                    }
&nbsp;
&nbsp;                    stackManipulations.add(stackManipulation);
&nbsp;                }
&nbsp;
&nbsp;                return new StackManipulation.Compound(new StackManipulation[]{ArrayFactory.forType(componentType).withValues(stackManipulations)});
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.parameters.equals(((ForMethodParameterArray)var1).parameters);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.parameters.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            public static enum ForInstrumentedMethod implements Factory, ArgumentProvider {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private ForInstrumentedMethod() {
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    return Collections.singletonList(new ForMethodParameterArray(instrumentedMethod.getParameters()));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForMethodParameter implements ArgumentLoader {
&nbsp;            private final int index;
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            public ForMethodParameter(int index, MethodDescription instrumentedMethod) {
&nbsp;                this.index = index;
&nbsp;                this.instrumentedMethod = instrumentedMethod;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                ParameterDescription parameterDescription = (ParameterDescription)this.instrumentedMethod.getParameters().get(this.index);
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.load(parameterDescription), assigner.assign(parameterDescription.getType(), target.getType(), typing)});
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + target + &quot; for &quot; + this.instrumentedMethod);
&nbsp;                } else {
&nbsp;                    return stackManipulation;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.index != ((ForMethodParameter)var1).index) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedMethod.equals(((ForMethodParameter)var1).instrumentedMethod);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.index) * 31 + this.instrumentedMethod.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Factory implements Factory, ArgumentProvider {
&nbsp;                private final int index;
&nbsp;
&nbsp;                public Factory(int index) {
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    if (this.index &gt;= instrumentedMethod.getParameters().size()) {
&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not have a parameter with index &quot; + this.index + &quot;, &quot; + instrumentedMethod.getParameters().size() + &quot; defined&quot;);
&nbsp;                    } else {
&nbsp;                        return Collections.singletonList(new ForMethodParameter(this.index, instrumentedMethod));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((Factory)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static enum OfInstrumentedMethod implements Factory, ArgumentProvider {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private OfInstrumentedMethod() {
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList(instrumentedMethod.getParameters().size());
&nbsp;                    Iterator var4 = instrumentedMethod.getParameters().iterator();
&nbsp;
&nbsp;                    while(var4.hasNext()) {
&nbsp;                        ParameterDescription parameterDescription = (ParameterDescription)var4.next();
&nbsp;                        argumentLoaders.add(new ForMethodParameter(parameterDescription.getIndex(), instrumentedMethod));
&nbsp;                    }
&nbsp;
&nbsp;                    return argumentLoaders;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForInstrumentedType implements ArgumentLoader, ArgumentProvider {
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            public ForInstrumentedType(TypeDescription instrumentedType) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                return Collections.singletonList(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(new StackManipulation[]{ClassConstant.of(this.instrumentedType), assigner.assign(ForLoadedType.of(Class.class), target.getType(), typing)});
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign Class value to &quot; + target);
&nbsp;                } else {
&nbsp;                    return stackManipulation;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedType.equals(((ForInstrumentedType)var1).instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.instrumentedType.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            public static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return new ForInstrumentedType(implementationTarget.getInstrumentedType());
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForThisReference implements ArgumentLoader, ArgumentProvider {
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            public ForThisReference(TypeDescription instrumentedType) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                if (instrumentedMethod.isStatic()) {
&nbsp;                    throw new IllegalStateException(instrumentedMethod + &quot; is static and cannot supply an invoker instance&quot;);
&nbsp;                } else {
&nbsp;                    return Collections.singletonList(this);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.loadThis(), assigner.assign(this.instrumentedType.asGenericType(), target.getType(), typing)});
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + this.instrumentedType + &quot; to &quot; + target);
&nbsp;                } else {
&nbsp;                    return stackManipulation;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.instrumentedType.equals(((ForThisReference)var1).instrumentedType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.instrumentedType.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            public static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                    return new ForThisReference(implementationTarget.getInstrumentedType());
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForNullConstant implements ArgumentLoader, ArgumentProvider, Factory {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForNullConstant() {
&nbsp;            }
&nbsp;
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public ArgumentProvider make(Implementation.Target implementationTarget) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                return Collections.singletonList(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                if (target.getType().isPrimitive()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign null to &quot; + target);
&nbsp;                } else {
&nbsp;                    return NullConstant.INSTANCE;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory extends InstrumentedType.Prepareable {
&nbsp;            ArgumentProvider make(Implementation.Target var1);
&nbsp;        }
&nbsp;
&nbsp;        public interface ArgumentProvider {
&nbsp;            List&lt;ArgumentLoader&gt; resolve(MethodDescription var1, MethodDescription var2);
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public interface MethodLocator {</b>
<b class="fc">&nbsp;        MethodDescription resolve(TypeDescription var1, MethodDescription var2);</b>
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForElementMatcher implements MethodLocator {
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;            private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
<b class="fc">&nbsp;            private final MethodGraph.Compiler methodGraphCompiler;</b>
&nbsp;
&nbsp;            protected ForElementMatcher(TypeDescription instrumentedType, ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;                this.matcher = matcher;
&nbsp;                this.methodGraphCompiler = methodGraphCompiler;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
&nbsp;                TypeDescription.Generic superClass = this.instrumentedType.getSuperClass();
&nbsp;                List&lt;MethodDescription&gt; candidates = CompoundList.of((List)(superClass == null ? Collections.emptyList() : superClass.getDeclaredMethods().filter(ElementMatchers.isConstructor().and(this.matcher))), this.instrumentedType.getDeclaredMethods().filter(ElementMatchers.not(ElementMatchers.isVirtual()).and(this.matcher)), this.methodGraphCompiler.compile(targetType, this.instrumentedType).listNodes().asMethodList().filter(this.matcher));
&nbsp;                if (candidates.size() == 1) {
&nbsp;                    return (MethodDescription)candidates.get(0);
&nbsp;                } else {
<b class="pc">&nbsp;                    throw new IllegalStateException(this.instrumentedType + &quot; does not define exactly one virtual method or constructor for &quot; + this.matcher + &quot; but contained &quot; + candidates.size() + &quot; candidates: &quot; + candidates);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.instrumentedType.equals(((ForElementMatcher)var1).instrumentedType)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.matcher.equals(((ForElementMatcher)var1).matcher)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.methodGraphCompiler.equals(((ForElementMatcher)var1).methodGraphCompiler);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.instrumentedType.hashCode()) * 31 + this.matcher.hashCode()) * 31 + this.methodGraphCompiler.hashCode();
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            @Enhance</b>
&nbsp;            public static class Factory implements Factory {
&nbsp;                private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;                private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;                public Factory(ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;                    this.matcher = matcher;</b>
&nbsp;                    this.methodGraphCompiler = methodGraphCompiler;
&nbsp;                }
&nbsp;
&nbsp;                public MethodLocator make(TypeDescription instrumentedType) {
&nbsp;                    return new ForElementMatcher(instrumentedType, this.matcher, this.methodGraphCompiler);
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                public boolean equals(@MaybeNull Object var1) {</b>
<b class="nc">&nbsp;                    if (this == var1) {</b>
&nbsp;                        return true;
<b class="fc">&nbsp;                    } else if (var1 == null) {</b>
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.matcher.equals(((Factory)var1).matcher)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.methodGraphCompiler.equals(((Factory)var1).methodGraphCompiler);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.matcher.hashCode()) * 31 + this.methodGraphCompiler.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForExplicitMethod implements MethodLocator, Factory {
&nbsp;            private final MethodDescription methodDescription;
&nbsp;
<b class="fc">&nbsp;            protected ForExplicitMethod(MethodDescription methodDescription) {</b>
<b class="fc">&nbsp;                this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public MethodLocator make(TypeDescription instrumentedType) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                return this.methodDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.methodDescription.equals(((ForExplicitMethod)var1).methodDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.methodDescription.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForInstrumentedMethod implements MethodLocator, Factory {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForInstrumentedMethod() {
&nbsp;            }
&nbsp;
&nbsp;            public MethodLocator make(TypeDescription instrumentedType) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
&nbsp;                return instrumentedMethod;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            MethodLocator make(TypeDescription var1);
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-05-14 20:57</div>
</div>
</body>
</html>
